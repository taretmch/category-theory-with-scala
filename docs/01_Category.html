
<!DOCTYPE HTML>
<html lang="ja" >
    <head>
        <meta charset="UTF-8">
        <title>1章 圏とは · Scala で始める圏論入門</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="圏論の勉強記録です。本章では、圏とは何かについて学んでいきます。圏の構成要素 - 対象、射 - と、圏が満たすべき性質 - 射の合成、合成の結合律、恒等射 - について見ていきます。">
        <meta name="generator" content="HonKit 5.1.4">
        <meta name="author" content="taretmch">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="02_Types_and_functions.html" />
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="検索ワードを入力" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    はじめに
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    第1部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.2.1" data-path="01_Category.html">
            
                <a href="01_Category.html">
            
                    
                    1章 圏とは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="02_Types_and_functions.html">
            
                <a href="02_Types_and_functions.html">
            
                    
                    2章 型と関数の圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="03_Categories_great_and_small.html">
            
                <a href="03_Categories_great_and_small.html">
            
                    
                    3章 いろいろな圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="04_Kleisli_category.html">
            
                <a href="04_Kleisli_category.html">
            
                    
                    4章 Kleisli圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="05_Products_and_Coproducts.html">
            
                <a href="05_Products_and_Coproducts.html">
            
                    
                    5, 6章 積と余積
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" >
            
                <span>
            
                    
                    6章 代数的データ型（一部は5章に）
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="07_Functor.html">
            
                <a href="07_Functor.html">
            
                    
                    7章 関手
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="08_Functoriality.html">
            
                <a href="08_Functoriality.html">
            
                    
                    8章 関手性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" >
            
                <span>
            
                    
                    （工事中）9章 関数型
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10_Natural_transformations.html">
            
                <a href="10_Natural_transformations.html">
            
                    
                    10章 自然変換
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    第2部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    （工事中）11章 宣言型プログラミング
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="12_Limits_and_Colimits.html">
            
                <a href="12_Limits_and_Colimits.html">
            
                    
                    12章 極限と余極限
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    付録
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="00_Notation.html">
            
                <a href="00_Notation.html">
            
                    
                    表記法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="tips/08_2_Writer_Functor.html">
            
                <a href="tips/08_2_Writer_Functor.html">
            
                    
                    Writer 圏における射の合成と、恒等射と、関手について
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            HonKitで公開 
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >1章 圏とは</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>本章では、hamcat ライブラリの以下の import を利用します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> hamcat.util.<span class="hljs-type">Eq</span>.===
</code></pre>
<!-- omit in toc -->
<h1 id="1-圏とは">1. 圏とは</h1>
<p>圏は、<strong>対象</strong> (object) の集まりと、対象から対象へのなんらかの操作を表す<strong>射</strong> (arrow, morphism) の集まりからなります。</p>
<p><img src="images/category.png" alt="圏のイメージ"></p>
<p>例えば、Scala を圏として考えてみると、対象は <code>Int</code>、 <code>String</code>、 <code>List[A]</code> などの型を表し，射は <code>f: Int -&gt; String</code> のように関数を表します。</p>
<p>他にも、対象を自然数の集まり <code>{0, 1, 2, ..., n, ...}</code> のみと考えてみると、射は自然数の間の操作を表します。射の例として加算、乗算、減算、除算や、自然数を+1した値を返すインクリメンタなどがあります。</p>
<p>圏の例は<a href="03_Categories_great_and_small.html">3章</a>で紹介します。本章では、圏とは何かについて学んでいきます。圏の構成要素 (対象、射) と、圏が満たすべき性質 (射の合成、合成の結合律、恒等射) について見ていきます。</p>
<!-- omit in toc -->
<h1 id="目次">目次</h1>
<ul>
<li><a href="#11-射について">1.1 射について</a><ul>
<li><a href="#111-射の例-四則演算">1.1.1 射の例: 四則演算</a></li>
<li><a href="#112-射の例-scala-の関数">1.1.2 射の例: Scala の関数</a></li>
<li><a href="#113-始域と終域">1.1.3 始域と終域</a></li>
</ul>
</li>
<li><a href="#12-射の合成">1.2 射の合成</a></li>
<li><a href="#13-合成の性質">1.3 合成の性質</a><ul>
<li><a href="#131-射の結合律">1.3.1 射の結合律</a></li>
<li><a href="#132-恒等射">1.3.2 恒等射</a></li>
</ul>
</li>
<li><a href="#まとめ">まとめ</a></li>
</ul>
<h2 id="11-射について">1.1 射について</h2>
<p>射とは、圏の対象から対象へのなんらかの操作を表すようなものです。例えば、自然数を対象とすれば、自然数の間の操作、つまり加算や減算のような操作が射とみなせます。プログラミングにおいては、ある型をある型に変換する関数は射とみなせます。</p>
<h3 id="111-射の例-四則演算">1.1.1 射の例: 四則演算</h3>
<p>射の例として、自然数間の四則演算を考えてみましょう。</p>
<p>対象 1 から対象 2 への射としては「1を足す操作」「2倍する操作」などがあり、対象 2 から対象 1 への射としては「1を引く操作」「2で割る操作」などがありますね。それぞれを <code>add1</code>, <code>double</code>, <code>minus1</code>, <code>div2</code> と命名すれば、以下のように表現できます。</p>
<pre><code>add1:   1 -&gt; 2
double: 1 -&gt; 2
minus1: 2 -&gt; 1
div2:   2 -&gt; 1
</code></pre><h3 id="112-射の例-scala-の関数">1.1.2 射の例: Scala の関数</h3>
<p>Scala の関数も射とみなせます。</p>
<p>数をインクリメントする (つまり1を足す) 関数 <code>increment: Int =&gt; Int</code> は、型 <code>Int</code> から型 <code>Int</code> への関数です。圏論の言葉にすると、<code>Int</code> 型という対象から <code>Int</code> 型という対象への射です。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increment</span></span>: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = _ + <span class="hljs-number">1</span>
</code></pre>
<pre><code class="lang-scala">increment(<span class="hljs-number">1</span>)
<span class="hljs-comment">// res0: Int = 2</span>
increment(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res1: Int = 4</span>
</code></pre>
<h3 id="113-始域と終域">1.1.3 始域と終域</h3>
<p>次に、射を議論する際によく使われる概念を定義しておきます。</p>
<p>射はある対象からある対象への操作を表します。それは、対象から対象への矢印のようなものと考えられます。</p>
<pre><code>f: a -&gt; b
</code></pre><p><img src="images/01_morphism.png" alt="射は対象から対象への矢印"></p>
<p>このとき、矢印が出ている方の対象のことを<strong>始域</strong>あるいは<strong>域</strong> (domain) と呼び、矢印の先の対象のことを<strong>終域</strong>あるいは<strong>余域</strong> (codomain) と呼びます。個人的には、始集合・終集合との関連で始域と終域の方が好きです。</p>
<p>しばしば、射 <code>f</code> の始域のことを <code>dom(f)</code> 、終域のことを <code>cod(f)</code> と表します。</p>
<pre><code>dom(f) は a
cod(f) は b
</code></pre><h2 id="12-射の合成">1.2 射の合成</h2>
<p>圏に関する最も重要な性質は、<strong>射の合成</strong>です。圏の本質は合成であり、合成の本質は圏であると言われたりします。射の合成について考えてみましょう。</p>
<p>入力に対して出力を返す「関数」は、射の例です。型  <code>A</code> の値を受け取って <code>B</code> の値を返す関数 <code>f</code> と、型 <code>B</code> の値を受け取って <code>C</code> の値を返す関数 <code>g</code> があるとしましょう。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span> = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span></span>[<span class="hljs-type">B</span>, <span class="hljs-type">C</span>]: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span> = ???
</code></pre>
<p><code>f</code> の返り値を <code>g</code> に渡すことによって、関数を合成できますね。そうすると、型 <code>A</code> から <code>C</code> への新しい関数 <code>fg</code> を定義できます。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fg</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">C</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span> = a =&gt; g(f(a))
</code></pre>
<p>また、Scala において、関数の合成は <code>compose</code> や <code>andThen</code> メソッドで書くことができます。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fg2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">C</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span> = g.compose(f)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fg3</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">C</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span> = f.andThen(g)
</code></pre>
<p>実際に関数を合成してみましょう。例として、以下のような <code>String</code> から <code>Int</code> への関数 <code>length</code> と、<code>Int</code> から <code>Boolean</code> への関数 <code>isEven</code> を考えてみます。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 文字列の長さを求める関数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span></span>: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Int</span> = _.length
length(<span class="hljs-string">&quot;abcdefg&quot;</span>)
<span class="hljs-comment">// res2: Int = 7</span>

<span class="hljs-comment">// 数が偶数かどうかを判定する関数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEven</span></span>: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Boolean</span> = _ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
isEven(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res3: Boolean = false</span>
isEven(<span class="hljs-number">8</span>)
<span class="hljs-comment">// res4: Boolean = true</span>
</code></pre>
<p><code>length</code> は文字列の長さを返す関数で、 <code>isEven</code> は数が偶数かどうかを判定する関数です。この2つの関数を合成してみると、以下のようになります。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 関数合成によって新しい関数を定義する</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLengthEven1</span></span>: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Boolean</span> = isEven.compose(length)
isLengthEven1(<span class="hljs-string">&quot;abcdefg&quot;</span>)
<span class="hljs-comment">// res5: Boolean = false</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLengthEven2</span></span>: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Boolean</span> = length.andThen(isEven)
isLengthEven2(<span class="hljs-string">&quot;abcdefg&quot;</span>)
<span class="hljs-comment">// res6: Boolean = false</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLengthEven3</span></span>: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Boolean</span> = str =&gt; isEven(length(str))
isLengthEven3(<span class="hljs-string">&quot;abcdefg&quot;</span>)
<span class="hljs-comment">// res7: Boolean = false</span>
</code></pre>
<p>これら <code>isLengthEven</code> 関数は、文字列に <code>length</code> 関数を適用したあと、その返り値に <code>isEven</code> 関数を適用するような新しい関数です。合成によって作られた関数は、しばしば<strong>合成関数</strong>と呼ばれます。</p>
<p>このように、射の例である関数は合成することができます。一般に、圏における射も合成することができます。ただし、2つの射の合成の結果は一意でなければなりません。すなわち、射の合成は以下のように定義されます。</p>
<hr>
<p>2つの射 <code>f</code> と <code>g</code> について、<code>cod(f) = dom(g)</code> であれば <code>dom(f)</code> から <code>cod(g)</code> への一意の射が存在します。そのような射を <code>f</code> と <code>g</code> の<strong>合成</strong> (composition) と呼び、<code>g . f</code> と書きます。</p>
<p><img src="images/01_composition.png" alt="射の合成"></p>
<hr>
<h2 id="13-合成の性質">1.3 合成の性質</h2>
<p>圏は対象の集まりと射の集まりからなるものと説明しましたが、圏にはもう少し厳密な定義があります。それは</p>
<ol>
<li><strong>射が合成できること</strong></li>
<li><strong>射が結合律を満たすこと</strong></li>
<li><strong>恒等射が定義されていること</strong></li>
</ol>
<p>です。合成については 1.2 節で見ましたので、ここでは 2 と 3 について説明していきます。</p>
<h3 id="131-射の結合律">1.3.1 射の結合律</h3>
<p>まずは、射の結合律についてです。結合律と言うと、足し算や掛け算の結合律や、論理演算の結合律が思い出されるのではないでしょうか。例えば</p>
<pre><code>1 + 2 + 3 = (1 + 2) + 3 = 1 + (2 + 3)
</code></pre><pre><code>1 ∨ 1 ∨ 0 = (1 ∨ 1) ∨ 0 = 1 ∨ (1 ∨ 0)
</code></pre><p>などです。</p>
<p>全くこの通りというわけではないのですが、射の結合律とは、以下のように定義されます。</p>
<hr>
<p>合成可能な3つの射 <code>f</code>, <code>g</code>, <code>h</code> があるとき、以下が成り立つならば射は結合律を満たすと言います。</p>
<pre><code>h . (g . f) = (h . g) . f = h . g. f
</code></pre><hr>
<p>結合律は、Scala で書くと以下のようになります（<code>===</code> は Hamcat で用意している「等しくあるべきものを主張するための文法」です）。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// f, g は先ほど定義したものを使います</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span></span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]: <span class="hljs-type">C</span> =&gt; <span class="hljs-type">D</span> = ???

<span class="hljs-comment">// h . (g . f) = (h . g) . f</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">associativeLaw1</span> </span>= h.compose(g.compose(f)) === (h.compose(g)).compose(f)

<span class="hljs-comment">// h . (g . f) = h . g . f</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">associativeLaw2</span> </span>= h.compose(g.compose(f)) === h.compose(g).compose(f)

<span class="hljs-comment">// (h . g) . f = h . g. f</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">associativeLaw3</span> </span>= (h.compose(g)).compose(f) === h.compose(g).compose(f)
</code></pre>
<p>具体的な関数で確かめてみましょう。</p>
<p><code>length</code> 関数, <code>isEven</code> 関数に加えて、次の関数を使います。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">negate</span></span>: <span class="hljs-type">Boolean</span> =&gt; <span class="hljs-type">Boolean</span> = b =&gt; !b
</code></pre>
<p>3つの関数を合成して、&quot;abcdefg&quot; という文字列を入力してみます。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// h . (g . f)</span>
(negate.compose((isEven.compose(length))))(<span class="hljs-string">&quot;abcdefg&quot;</span>)
<span class="hljs-comment">// (h . g) . f</span>
((negate.compose(isEven)).compose(length))(<span class="hljs-string">&quot;abcdefg&quot;</span>)
<span class="hljs-comment">// h . g . f</span>
(negate.compose(isEven).compose(length))(<span class="hljs-string">&quot;abcdefg&quot;</span>)
<span class="hljs-comment">// res8: Boolean = true</span>
</code></pre>
<p>すべての計算の結果は等しく、確かに結合律は成り立っています。</p>
<h3 id="132-恒等射">1.3.2 恒等射</h3>
<p>次に、恒等射についてです。あるシステムが圏であるためには、任意の対象について恒等射が存在しなければいけません。この条件を<strong>単位律</strong>と呼びます。</p>
<p><strong>恒等射</strong> (identity) は、他の射と合成するとその射そのものになるような射です。射の合成の<strong>単位元</strong> (unit) とも言います。つまり、ある関数 <code>f</code> と恒等射 <code>id</code> とを合成すると、その結果は <code>f</code> になります。</p>
<pre><code>f . id[A] = f
id[B] . f = f
</code></pre><p>Scala:</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identityLaw1</span></span>[<span class="hljs-type">A</span>] = (f.compose(identity[<span class="hljs-type">A</span>])) === f
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identityLaw2</span></span>[<span class="hljs-type">B</span>] = (identity[<span class="hljs-type">B</span>].compose(f)) === f
</code></pre>
<p>要は、入力と出力が等しい関数です。かなり噛み砕いて言うと、何もしない操作とも捉えることができるかもしれません。
Scala において、恒等射を表す identity 関数は以下のように定義されています。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identity</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">A</span> = a =&gt; a
</code></pre>
<p>何もしない操作が何に使えるのか、わかりづらいですよね。何もしないのなら使う場面もわからないし、定義になんて組み込む必要ないじゃん、と思うかもしれません。</p>
<p>では、何もしない操作についてもう少し考えてみましょう。</p>
<p>「何もしない」で最も典型的なものは 0 という数ではないでしょうか。0 は、加算という射における単位元です。これは、以下が成り立つことを意味します。</p>
<pre><code>x + 0 = x
</code></pre><p>これは当然のように成り立ちますよね。</p>
<p>他に、乗算という射における単位元は 1 です。これは、以下が成り立つことを意味します。</p>
<pre><code>x * 1 = x
</code></pre><p>単位元についてもう少し掘り下げてみます。</p>
<p>ある操作をしたあとにもう一つ操作をすると、単位元が得られる場合を考えます。すなわち、射 <code>f</code> と射 <code>g</code> を合成すると恒等射 <code>id</code> が得られたとします。</p>
<pre><code>g . f = id
</code></pre><p>このとき <code>g</code> は、 <code>f</code> と逆の操作をやった結果何もしない操作が得られたという意味から、 <code>f</code> の<strong>逆射</strong> (inverse) であるといわれます。</p>
<p>では、加算と乗算の逆射は何でしょうか。加算の単位元は 0、乗算の単位元は 1 なので、ある操作をしたあとにもう一つ操作をすると単位元が得られる、とは以下の状況を意味します。</p>
<pre><code>x + (- x) = 0
x * (1 / x) = 1
</code></pre><p>加算 <code>+ x</code> に対して <code>- x</code> すると単位元 0 が得られ、乗算 <code>* x</code> に対して <code>* 1/x</code> すると単位元 1 が得られています。これらはそれぞれ減算、除算です。すなわち、加算の逆射は減算、乗算の逆射は除算ですね。</p>
<p>以上の通り、何もしない操作である恒等射は、ある操作とは逆の操作を行う逆射の存在を扱うのにも必要な概念です。</p>
<p>対象 <code>A</code> から <code>B</code> への射に逆射が存在するとき、相互変換可能であるという意味で <code>A</code> と <code>B</code> は<strong>同型</strong> (isomorphic) であると言われます。また、射 <code>f</code> の逆射が存在することを <code>f</code> は<strong>可逆</strong> (invertible) であるといい、可逆な射を<strong>同型射</strong> (isomorphism) と呼びます。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><p>圏の定義: 圏は対象の集まりと射の集まりから構成され、以下の条件を満たすシステムである。</p>
<ol>
<li>射 <code>f: a -&gt; b</code> と射 <code>g: b -&gt; c</code> に対して、合成射 <code>g . f: a -&gt; c</code> が定義される。Scala においては <code>compose</code> メソッド。</li>
<li>射の合成について、結合律が成り立つ。</li>
<li>任意の対象について、恒等射が存在する。</li>
</ol>
</li>
<li><p>ある射 <code>f: a -&gt; b</code> に対して、 <code>g . f = id[A]</code> かつ<code>f . g = id[B]</code> を満たす射 <code>g: b -&gt; a</code> を <code>f</code> の逆射と呼ぶ。</p>
</li>
<li>射 <code>f</code> の逆射が存在するとき、 <code>f</code> は可逆であると呼ばれる。</li>
<li>可逆な射は同型射と呼ばれる。</li>
<li>対象 <code>a</code> から <code>b</code> への射が同型射であるとき、 <code>a</code> と <code>b</code> は同型であると呼ばれる。</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="02_Types_and_functions.html" class="navigation navigation-next navigation-unique" aria-label="Next page: 2章 型と関数の圏">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"圏論の勉強記録です。本章では、圏とは何かについて学んでいきます。圏の構成要素 - 対象、射 - と、圏が満たすべき性質 - 射の合成、合成の結合律、恒等射 - について見ていきます。","title":"1章 圏とは","level":"1.2.1","depth":2,"next":{"title":"2章 型と関数の圏","level":"1.2.2","depth":2,"path":"02_Types_and_functions.md","ref":"02_Types_and_functions.md","articles":[]},"previous":{"title":"第1部","level":"1.2","depth":1,"ref":"","articles":[{"title":"1章 圏とは","level":"1.2.1","depth":2,"path":"01_Category.md","ref":"01_Category.md","articles":[]},{"title":"2章 型と関数の圏","level":"1.2.2","depth":2,"path":"02_Types_and_functions.md","ref":"02_Types_and_functions.md","articles":[]},{"title":"3章 いろいろな圏","level":"1.2.3","depth":2,"path":"03_Categories_great_and_small.md","ref":"03_Categories_great_and_small.md","articles":[]},{"title":"4章 Kleisli圏","level":"1.2.4","depth":2,"path":"04_Kleisli_category.md","ref":"04_Kleisli_category.md","articles":[]},{"title":"5, 6章 積と余積","level":"1.2.5","depth":2,"path":"05_Products_and_Coproducts.md","ref":"05_Products_and_Coproducts.md","articles":[]},{"title":"6章 代数的データ型（一部は5章に）","level":"1.2.6","depth":2,"ref":"","articles":[]},{"title":"7章 関手","level":"1.2.7","depth":2,"path":"07_Functor.md","ref":"07_Functor.md","articles":[]},{"title":"8章 関手性","level":"1.2.8","depth":2,"path":"08_Functoriality.md","ref":"08_Functoriality.md","articles":[]},{"title":"（工事中）9章 関数型","level":"1.2.9","depth":2,"ref":"","articles":[]},{"title":"10章 自然変換","level":"1.2.10","depth":2,"path":"10_Natural_transformations.md","ref":"10_Natural_transformations.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":[],"root":"./mdoc-output","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"taretmch","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Scala で始める圏論入門","language":"ja","gitbook":"*","description":"本サイトは、圏論初心者が圏論について学びながら作成した、Scala プログラマのための入門書です。教科書は Bartosz Milewski 氏著の Category Theory for Programmers の Scala Edition で、構成も原則これに沿っています。Scala をやっていて、圏論について知りたい・学ぶ土台を作りたいという方の参考になれば幸いです。"},"file":{"path":"01_Category.md","mtime":"2024-06-30T02:17:55.857Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-06-30T02:18:08.192Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

