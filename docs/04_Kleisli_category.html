
<!DOCTYPE HTML>
<html lang="ja" >
    <head>
        <meta charset="UTF-8">
        <title>4章 Kleisli圏 · Scala で始める圏論入門</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="圏論の勉強記録です。本章では、計算効果についてのイメージを深めるため、ロギングの計算効果を圏で扱う方法を学びます。計算効果と言えばモナドですが、まだ学んでいないためモナドの概念は出さずに考えていきます。">
        <meta name="generator" content="HonKit 5.1.4">
        <meta name="author" content="taretmch">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="05_Products_and_Coproducts.html" />
    
    
    <link rel="prev" href="03_Categories_great_and_small.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="検索ワードを入力" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    はじめに
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    第1部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="01_Category.html">
            
                <a href="01_Category.html">
            
                    
                    1章 圏とは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="02_Types_and_functions.html">
            
                <a href="02_Types_and_functions.html">
            
                    
                    2章 型と関数の圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="03_Categories_great_and_small.html">
            
                <a href="03_Categories_great_and_small.html">
            
                    
                    3章 いろいろな圏
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.4" data-path="04_Kleisli_category.html">
            
                <a href="04_Kleisli_category.html">
            
                    
                    4章 Kleisli圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="05_Products_and_Coproducts.html">
            
                <a href="05_Products_and_Coproducts.html">
            
                    
                    5, 6章 積と余積
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" >
            
                <span>
            
                    
                    6章 代数的データ型（一部は5章に）
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="07_Functor.html">
            
                <a href="07_Functor.html">
            
                    
                    7章 関手
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="08_Functoriality.html">
            
                <a href="08_Functoriality.html">
            
                    
                    8章 関手性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" >
            
                <span>
            
                    
                    （工事中）9章 関数型
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10_Natural_transformations.html">
            
                <a href="10_Natural_transformations.html">
            
                    
                    10章 自然変換
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    第2部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    （工事中）11章 宣言型プログラミング
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="12_Limits_and_Colimits.html">
            
                <a href="12_Limits_and_Colimits.html">
            
                    
                    12章 極限と余極限
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    付録
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="00_Notation.html">
            
                <a href="00_Notation.html">
            
                    
                    表記法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="tips/08_2_Writer_Functor.html">
            
                <a href="tips/08_2_Writer_Functor.html">
            
                    
                    Writer 圏における射の合成と、恒等射と、関手について
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            HonKitで公開 
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >4章 Kleisli圏</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <!-- omit in toc -->
<h1 id="4-kleisli-圏">4. Kleisli 圏</h1>
<p>ここまでで、型と純粋関数を圏としてモデル化する方法をみてきました。その際に計算効果を持つ非純粋な関数をモデル化するための概念として、モナドが出てきましたね。</p>
<p>ここでは、計算効果の例として、実行内容のログ、トレースを行うことについて考えていきます。モナドの1つの例である Writer、そして Writer の一般化である Kleisli について見ていきましょう。</p>
<!-- omit in toc -->
<h1 id="目次">目次</h1>
<ul>
<li><a href="#41-ロギング関数の合成">4.1 ロギング関数の合成</a></li>
<li><a href="#42-writer-圏">4.2 Writer 圏</a><ul>
<li><a href="#421-writer-圏の対象と射">4.2.1 Writer 圏の対象と射</a></li>
<li><a href="#422-writer-圏における射の合成">4.2.2 Writer 圏における射の合成</a></li>
<li><a href="#423-writer-圏は圏の公理を満たすか">4.2.3 Writer 圏は圏の公理を満たすか</a></li>
<li><a href="#424-writer-圏のより一般的な定義">4.2.4 Writer 圏のより一般的な定義</a></li>
</ul>
</li>
<li><a href="#43-kleisli-圏">4.3 Kleisli 圏</a></li>
<li><a href="#まとめ">まとめ</a></li>
</ul>
<h2 id="41-ロギング関数の合成">4.1 ロギング関数の合成</h2>
<p>計算効果の例として、プログラムの実行をロギングする関数について考えます。</p>
<p>命令型のように書くと、グローバルな状態にログを記録することが多いかなと思います。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 副作用が生じる例</span>
<span class="hljs-keyword">var</span> logger: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span>
<span class="hljs-comment">// logger: String = &quot;&quot;</span>

<span class="hljs-comment">// ログを出力する関数 (純粋関数ではない)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">negateUnpure</span></span>(b: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Boolean</span> =
  logger += <span class="hljs-string">s&quot;negate is called with parameter <span class="hljs-subst">$b</span>&quot;</span>
  !b
</code></pre>
<p>この関数には副作用があります。並列実行されるときのことを考えると、このようなコードは好ましくありませんね。</p>
<p>この関数を純粋関数にするにはどうしたら良いでしょうか。幸い、出力されるログを出力に加えるだけでなんとかなりそうです。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">negatePure</span></span>(b: <span class="hljs-type">Boolean</span>, logger: <span class="hljs-type">String</span>): (<span class="hljs-type">Boolean</span>, <span class="hljs-type">String</span>) =
  (!b, logger + <span class="hljs-string">s&quot;negate is called with parameter <span class="hljs-subst">$b</span>&quot;</span>)
</code></pre>
<p>この関数は副作用がなく、純粋です。同じ引数で呼び出されると全く同じ出力を返します。</p>
<pre><code class="lang-scala">negatePure(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;hoge: &quot;</span>)
<span class="hljs-comment">// res0: Tuple2[Boolean, String] = (</span>
<span class="hljs-comment">//   false,</span>
<span class="hljs-comment">//   &quot;hoge: negate is called with parameter true&quot;</span>
<span class="hljs-comment">// )</span>
negatePure(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;fuga: &quot;</span>)
<span class="hljs-comment">// res1: Tuple2[Boolean, String] = (</span>
<span class="hljs-comment">//   false,</span>
<span class="hljs-comment">//   &quot;fuga: negate is called with parameter true&quot;</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>この関数は純粋ですが、入力に <code>logger: String</code> を渡さないといけないのがインタフェースとして不便ですね。そこで次のような型を導入してみましょう。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>[<span class="hljs-type">A</span>](<span class="hljs-params">run: (<span class="hljs-type">String</span>, <span class="hljs-type">A</span></span>))</span>
</code></pre>
<p>この <code>Writer</code> クラスは、任意の型 <code>A</code> になんらかの文字列の値を付与した構造を持ちます。このクラスを用いると、 <code>negate</code> 関数は以下のように書くことができます。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">negate</span></span>(b: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Writer</span>[<span class="hljs-type">Boolean</span>] =
  <span class="hljs-type">Writer</span>(
    <span class="hljs-string">s&quot;negate is called with parameter <span class="hljs-subst">$b</span>. &quot;</span> -&gt;
    !b
  )

negate(<span class="hljs-literal">true</span>)
<span class="hljs-comment">// res2: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;negate is called with parameter true. &quot;, false)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>純粋ではありますが、<code>Writer</code> にこれまでのログの情報を渡して集約しなければいけません。どうしたら良いでしょうか。</p>
<p>試しに、ある Writer <code>Writer[A]</code> に対して、別の Writer を生成するような計算 <code>A =&gt; Writer[B]</code> を合成する関数 <code>flatMap</code> について考えてみます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">extension</span> [<span class="hljs-type">A</span>](v: <span class="hljs-type">Writer</span>[<span class="hljs-type">A</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Writer</span>[<span class="hljs-type">B</span>] =
    <span class="hljs-keyword">val</span> (logA, resA) = v.run
    <span class="hljs-keyword">val</span> (logB, resB) = f(resA).run
    <span class="hljs-type">Writer</span>((logA + logB, resB))
</code></pre>
<pre><code class="lang-scala"><span class="hljs-type">Writer</span>(<span class="hljs-string">&quot;initial log. &quot;</span> -&gt; <span class="hljs-literal">true</span>).flatMap(negate)
<span class="hljs-comment">// res3: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;initial log. negate is called with parameter true. &quot;, false)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>flatMap ですので、map を定義すれば for 糖衣構文を利用することができます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">extension</span> [<span class="hljs-type">A</span>](v: <span class="hljs-type">Writer</span>[<span class="hljs-type">A</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Writer</span>[<span class="hljs-type">B</span>] =
    <span class="hljs-keyword">val</span> (logA, resA) = v.run
    <span class="hljs-type">Writer</span>(logA, f(resA))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEven</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Writer</span>[<span class="hljs-type">Boolean</span>] =
  <span class="hljs-type">Writer</span>(
    <span class="hljs-string">s&quot;isEven is called with parameter <span class="hljs-subst">$n</span>. &quot;</span>,
    n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
  )

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isOdd</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Writer</span>[<span class="hljs-type">Boolean</span>] =
  <span class="hljs-keyword">for</span>
    isEvenRes &lt;- isEven(n)
    negateRes &lt;- negate(isEvenRes)
  <span class="hljs-keyword">yield</span> negateRes

isOdd(<span class="hljs-number">1</span>)
<span class="hljs-comment">// res4: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (</span>
<span class="hljs-comment">//     &quot;isEven is called with parameter 1. negate is called with parameter false. &quot;,</span>
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
isOdd(<span class="hljs-number">2</span>)
<span class="hljs-comment">// res5: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (</span>
<span class="hljs-comment">//     &quot;isEven is called with parameter 2. negate is called with parameter true. &quot;,</span>
<span class="hljs-comment">//     false</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
<span class="hljs-type">Writer</span>(<span class="hljs-string">&quot;initial log. &quot;</span> -&gt; <span class="hljs-number">3</span>).flatMap(isOdd)
<span class="hljs-comment">// res6: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (</span>
<span class="hljs-comment">//     &quot;initial log. isEven is called with parameter 3. negate is called with parameter false. &quot;,</span>
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>これで、通常のロジック (この簡単な例では、奇数か偶数か判定するプログラム) からログの合成については考えなくて良くなりました。各関数は、純粋関数として自分たちのログを出力に入れるだけで良いですね。</p>
<p>実は、今考えたような構造は Writer 圏と呼ばれます。次の節では Writer 圏を定式化していきます。</p>
<h2 id="42-writer-圏">4.2 Writer 圏</h2>
<p>先ほど見たロギング関数の合成の例を圏論の言葉に落とし込むと、Writer 圏というものを考えることができます。</p>
<h3 id="421-writer-圏の対象と射">4.2.1 Writer 圏の対象と射</h3>
<p>Writer 圏では、先ほど定義したデータ型 <code>Writer</code> を利用します。</p>
<p>この圏では、対象として型を採用し、対象 <code>A</code> から <code>B</code> への射として以下のようにラップされた関数を採用します：</p>
<pre><code class="lang-scala"><span class="hljs-comment">// Writer 圏における射</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">B</span>] = ???
</code></pre>
<p><img src="images/morphism_in_writer_category.png" alt="Writer圏における射"></p>
<p>つまり、Writer 圏においては、関数 <code>g: A =&gt; B</code> は射ではありません。</p>
<p>2つの関数 <code>negate: Boolean =&gt; Writer[Boolean]</code> と <code>isEven: Int =&gt; Writer[Boolean]</code> は、Writer 圏における射です。</p>
<p><img src="images/morphism_example_in_writer_category.png" alt="Writer圏における射の例"></p>
<h3 id="422-writer-圏における射の合成">4.2.2 Writer 圏における射の合成</h3>
<p>Writer 圏における射の合成は、先ほど定義した <code>flatMap</code> と似たようなものになります。関数 <code>f: A =&gt; Writer[B]</code>、関数 <code>g: B =&gt; Writer[C]</code> を合成した関数 <code>f &gt;=&gt; g: A =&gt; Writer[C]</code> を定義してみましょう。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Writer</span></span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&gt;=&gt;</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>]: (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">B</span>]) =&gt; (<span class="hljs-type">B</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">C</span>]) =&gt; (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">C</span>]) = f =&gt; g =&gt; a =&gt;
    <span class="hljs-keyword">val</span> (logF, b) = f(a).run
    <span class="hljs-keyword">val</span> (logG, c) = g(b).run
    <span class="hljs-type">Writer</span>((logF + logG), c)

<span class="hljs-keyword">extension</span> [<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">B</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&gt;=&gt;</span></span>[<span class="hljs-type">C</span>](g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">C</span>]): <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">C</span>] =
    <span class="hljs-type">Writer</span>.&gt;=&gt;(f)(g)
</code></pre>
<p><code>&gt;=&gt;</code> 演算は fish 演算子と呼ばれるもので、 <code>andThen</code> や <code>compose</code> と同様、引数で受け取った2つの関数を合成した関数を返します。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isOdd2</span> </span>= isEven &gt;=&gt; negate

isOdd(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res7: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (</span>
<span class="hljs-comment">//     &quot;isEven is called with parameter 3. negate is called with parameter false. &quot;,</span>
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p><img src="images/morphism_composition_example_in_writer_category.png" alt="Writer圏における射の合成"></p>
<p>これで、Writer 圏における関数合成を定義できました！</p>
<h3 id="423-writer-圏は圏の公理を満たすか">4.2.3 Writer 圏は圏の公理を満たすか</h3>
<p>ここで一度、圏が満たすべき性質に立ち戻ってみましょう。1つ目は関数の合成が結合律を満たすこと、2つ目は任意の対象に対して恒等射が存在することでした。</p>
<p>この合成 <code>&gt;=&gt;</code> は、結合律を満たすでしょうか？</p>
<p>タプル <code>(String, A)</code> の各要素に分解して考えてみましょう。1つ目の要素の合成は、 <code>String</code> の連結です。文字列の連結が結合律を満たすのは自明ですね。</p>
<p>2つ目の要素の合成は、標準的な関数合成です。これも結合律を満たしますね。</p>
<p><code>&gt;=&gt;</code> の内部では文字列の連結と標準的な関数合成をしているだけなので、<code>&gt;=&gt;</code> は結合律を満たします。</p>
<p>恒等射の存在についてはどうでしょうか。実はこれまでの議論に恒等射は出ていないので、新しく定義します。</p>
<p>Writer 圏における恒等射の型は <code>A =&gt; Writer[A]</code> ですね。また、恒等射は、とある射と合成するとその射そのものになるような射でした。すなわち、関数 <code>f: A =&gt; Writer[B]</code> に対して、恒等射を <code>i: A =&gt; Writer[A]</code> とすると、以下の性質が成り立つはずです。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> hamcat.util.<span class="hljs-type">Eq</span>.===

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">A</span>] = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identityLaw1</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = (f[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] &gt;=&gt; i[<span class="hljs-type">B</span>]) === f[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identityLaw2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = (i[<span class="hljs-type">A</span>] &gt;=&gt; f[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]) === f[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]
</code></pre>
<p>そのような関数を <code>pure: A =&gt; Writer[A]</code> として定義しましょう。単位律を満たすために、1つ目の要素であるログ文字列はそのまま返し、2つ目の要素である計算結果はそのまま返す関数として実装します。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">A</span>] = a =&gt; <span class="hljs-type">Writer</span>(<span class="hljs-string">&quot;&quot;</span> -&gt; a)

pure(<span class="hljs-number">1</span>)
<span class="hljs-comment">// res8: Writer[Int] = Writer(run = (&quot;&quot;, 1))</span>
pure(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res9: Writer[Int] = Writer(run = (&quot;&quot;, 3))</span>
</code></pre>
<p>Writer 圏における射 <code>negate</code> <code>isEven</code> と合成してみましょう。</p>
<pre><code class="lang-scala">negate(<span class="hljs-literal">true</span>)
<span class="hljs-comment">// res10: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;negate is called with parameter true. &quot;, false)</span>
<span class="hljs-comment">// )</span>

(pure &gt;=&gt; negate)(<span class="hljs-literal">true</span>)
<span class="hljs-comment">// res11: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;negate is called with parameter true. &quot;, false)</span>
<span class="hljs-comment">// )</span>

(negate &gt;=&gt; pure)(<span class="hljs-literal">true</span>)
<span class="hljs-comment">// res12: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;negate is called with parameter true. &quot;, false)</span>
<span class="hljs-comment">// )</span>

isEven(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res13: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;isEven is called with parameter 3. &quot;, false)</span>
<span class="hljs-comment">// )</span>

(pure &gt;=&gt; isEven)(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res14: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;isEven is called with parameter 3. &quot;, false)</span>
<span class="hljs-comment">// )</span>

(isEven &gt;=&gt; pure)(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res15: Writer[Boolean] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;isEven is called with parameter 3. &quot;, false)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>合成すると同じ値が返ってくることを確認できましたね。<code>pure</code> は任意の型 <code>A</code> に対して同じ挙動をするので、<code>pure</code> は恒等射です。したがって、Writer 圏は単位律を満たします。</p>
<p>以上のことから、ここで定義した Writer 圏は圏であるといえます (ただし、例で見ているので、厳密に証明していません)。Writer 圏についてまとめると、次の図のようになります。</p>
<p><img src="images/04_example_of_writer_category.png" alt="Writer圏についてのまとめ"></p>
<h3 id="424-writer-圏のより一般的な定義">4.2.4 Writer 圏のより一般的な定義</h3>
<p>ここで定義した Writer 圏はもう少し抽象的にすることができます。Writer 圏が結合律と単位律を満たすためには、文字列の連結が結合律を満たし、文字列の連結に関する単位元 <code>&quot;&quot;</code> が定義されている必要がありました。つまり、ログを表現する型がモノイド的な性質を満たしていれば、Writer 圏は圏として定義できるはずです。</p>
<p>したがって、型 <code>Writer</code> は、以下のように定義していたものを</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>[<span class="hljs-type">A</span>](<span class="hljs-params">run: (<span class="hljs-type">String</span>, <span class="hljs-type">A</span></span>))</span>
</code></pre>
<p>以下のようにパラメータ化して定義できます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>](<span class="hljs-params">run: (<span class="hljs-type">L</span>, <span class="hljs-type">A</span></span>))</span>
</code></pre>
<p>ただし、型 <code>L</code> はモノイドであることが条件です。</p>
<p>これまでの議論を元に、<code>Writer</code> を以下のように定義できます。<code>Writer</code> のデータそのものはタプル <code>(L, A)</code> です。関数を合成するための <code>flatMap</code> メソッド (厳密には <code>&gt;=&gt;</code> ですが)、恒等射の <code>pure</code> メソッドを定義できます。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// Semigroup (半群) は combine だけを持った型クラス</span>
<span class="hljs-keyword">import</span> hamcat.<span class="hljs-type">Semigroup</span>
<span class="hljs-keyword">import</span> hamcat.<span class="hljs-type">Monoid</span>
<span class="hljs-keyword">import</span> hamcat.syntax.semigroup.*

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>](<span class="hljs-params">run: (<span class="hljs-type">L</span>, <span class="hljs-type">A</span></span>))</span>:

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">B</span>])(<span class="hljs-keyword">using</span> <span class="hljs-type">Semigroup</span>[<span class="hljs-type">L</span>]): <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">B</span>] =
    <span class="hljs-keyword">val</span> (log, res) = run
    <span class="hljs-keyword">val</span> (logF, resF) = f(res).run
    <span class="hljs-type">Writer</span>((log |+| logF, resF))

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Writer</span></span>:

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>)(<span class="hljs-keyword">using</span> m: <span class="hljs-type">Monoid</span>[<span class="hljs-type">L</span>]): <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">Writer</span>((m.empty, a))
</code></pre>
<h2 id="43-kleisli-圏">4.3 Kleisli 圏</h2>
<p>前節で議論した Writer 圏は、実は Kleisli 圏 (Kleisli category) と呼ばれるものの例です。Kleisli 圏はモナドに基づく圏ですので、厳密な定義はモナドを学んでから見ていきます。</p>
<p>Kleisli 圏では、対象を型、型 <code>A</code> から型 <code>B</code> への射を型 <code>F</code> に対して <code>A =&gt; F[B]</code> である関数とします。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kleisli</span>[<span class="hljs-type">F</span>[_], <span class="hljs-title">A</span>, <span class="hljs-title">B</span>](<span class="hljs-params">run: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]</span>)</span>
</code></pre>
<p>ここで <code>F</code> は自己関手という概念に対応することを後の章で見ていきます。<code>F</code> の例としては <code>List</code> や <code>Option</code> などがあります。それぞれの Kleisli 圏において、射の合成は独自の方法で実装されます。これはまさに1つの自由度であり、ロギングやエラーなどの計算効果に対して表示的意味論を与えることができます。</p>
<p>後の章で、モナドを使って Kleisli 圏を定義します。そのときにまた、本章で述べたことを思い出してもらえると幸いです。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>関数 <code>f: A =&gt; F[B]</code> が圏の公理を満たすよう、射の合成を定義したものが Kleisli 圏である。</li>
<li>Writer 圏は Kleisli 圏の例である。</li>
<li>Writer 圏では、期待する出力 <code>B</code> の他にログ <code>L</code> を出力する関数 <code>f: A =&gt; Writer[L, B]</code> を射として考える。<ul>
<li><code>L</code> は、その射において結合律を満たし、射に関する単位元を持つ必要がある。すなわち、<code>L</code> はモノイドの性質を満たす必要がある。</li>
</ul>
</li>
<li>Writer 圏における射の合成は <code>&gt;=&gt;</code> 演算子として定義された。</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="03_Categories_great_and_small.html" class="navigation navigation-prev " aria-label="Previous page: 3章 いろいろな圏">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="05_Products_and_Coproducts.html" class="navigation navigation-next " aria-label="Next page: 5, 6章 積と余積">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"圏論の勉強記録です。本章では、計算効果についてのイメージを深めるため、ロギングの計算効果を圏で扱う方法を学びます。計算効果と言えばモナドですが、まだ学んでいないためモナドの概念は出さずに考えていきます。","title":"4章 Kleisli圏","level":"1.2.4","depth":2,"next":{"title":"5, 6章 積と余積","level":"1.2.5","depth":2,"path":"05_Products_and_Coproducts.md","ref":"05_Products_and_Coproducts.md","articles":[]},"previous":{"title":"3章 いろいろな圏","level":"1.2.3","depth":2,"path":"03_Categories_great_and_small.md","ref":"03_Categories_great_and_small.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./mdoc-output","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"taretmch","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Scala で始める圏論入門","language":"ja","gitbook":"*","description":"本サイトは、圏論初心者が圏論について学びながら作成した、Scala プログラマのための入門書です。教科書は Bartosz Milewski 氏著の Category Theory for Programmers の Scala Edition で、構成も原則これに沿っています。Scala をやっていて、圏論について知りたい・学ぶ土台を作りたいという方の参考になれば幸いです。"},"file":{"path":"04_Kleisli_category.md","mtime":"2024-07-02T15:57:18.674Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-07-02T15:57:28.516Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

