
<!DOCTYPE HTML>
<html lang="ja" >
    <head>
        <meta charset="UTF-8">
        <title>7章 関手 · Scala で始める圏論入門</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="圏論の勉強記録です。本章では、圏から圏への対応である関手について定義し、プログラミングにおける関手の例（Option 関手や Reader 関手）を示します。">
        <meta name="generator" content="HonKit 5.1.4">
        <meta name="author" content="taretmch">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="08_Functoriality.html" />
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="検索ワードを入力" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    はじめに
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    第1部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="01_Category.html">
            
                <a href="01_Category.html">
            
                    
                    1章 圏とは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="02_Types_and_functions.html">
            
                <a href="02_Types_and_functions.html">
            
                    
                    2章 型と関数の圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="03_Categories_great_and_small.html">
            
                <a href="03_Categories_great_and_small.html">
            
                    
                    3章 いろいろな圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="04_Kleisli_category.html">
            
                <a href="04_Kleisli_category.html">
            
                    
                    4章 Kleisli圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="05_Products_and_Coproducts.html">
            
                <a href="05_Products_and_Coproducts.html">
            
                    
                    5, 6章 積と余積
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" >
            
                <span>
            
                    
                    6章 代数的データ型（一部は5章に）
            
                </span>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.7" data-path="07_Functor.html">
            
                <a href="07_Functor.html">
            
                    
                    7章 関手
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="08_Functoriality.html">
            
                <a href="08_Functoriality.html">
            
                    
                    8章 関手性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" >
            
                <span>
            
                    
                    （工事中）9章 関数型
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10_Natural_transformations.html">
            
                <a href="10_Natural_transformations.html">
            
                    
                    10章 自然変換
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    第2部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    （工事中）11章 宣言型プログラミング
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="12_Limits_and_Colimits.html">
            
                <a href="12_Limits_and_Colimits.html">
            
                    
                    12章 極限と余極限
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    付録
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="00_Notation.html">
            
                <a href="00_Notation.html">
            
                    
                    表記法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="tips/08_2_Writer_Functor.html">
            
                <a href="tips/08_2_Writer_Functor.html">
            
                    
                    Writer 圏における射の合成と、恒等射と、関手について
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            HonKitで公開 
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >7章 関手</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <!-- omit in toc -->
<h1 id="7-関手">7. 関手</h1>
<p>圏は対象の集まりと射の集まりからなりますが、これまでに何度か「対象を圏として圏を構成できるのではないか？」と思った人もいるのではないでしょうか。</p>
<p>その疑問に対する答えは「できる」です。今回定義する関手を使えば、圏の構造（つまり、圏の図式の形）を維持したまま別の圏に変換できるようになります。</p>
<p>関手は、非常に単純ですが強力な概念です。本章では、関手とは何かについて定義し、プログラミングにおける関手の例を示します。</p>
<!-- omit in toc -->
<h1 id="目次">目次</h1>
<ul>
<li><a href="#71-関手とは">7.1 関手とは</a><ul>
<li><a href="#711-対象関数">7.1.1 対象関数</a></li>
<li><a href="#712-射関数">7.1.2 射関数</a></li>
<li><a href="#713-関手の定義">7.1.3 関手の定義</a></li>
</ul>
</li>
<li><a href="#72-プログラミングにおける関手">7.2 プログラミングにおける関手</a><ul>
<li><a href="#721-functor-型クラス">7.2.1 Functor 型クラス</a></li>
<li><a href="#722-option-関手">7.2.2 Option 関手</a></li>
<li><a href="#723-reader-関手">7.2.3 Reader 関手</a></li>
<li><a href="#724-writer-関手">7.2.4 Writer 関手</a></li>
</ul>
</li>
<li><a href="#73-関手の合成">7.3 関手の合成</a></li>
<li><a href="#まとめ">まとめ</a></li>
</ul>
<h2 id="71-関手とは">7.1 関手とは</h2>
<p><strong>関手</strong> (functor) は、ある圏 <strong>C</strong> を別のある圏 <strong>D</strong> に変換する対応 F のことです。</p>
<p>関手の例としては Option 関手、List 関手、Writer 関手、モノイド準同型などがあります。モノイド準同型は、モノイド間の関手です。</p>
<p>Option 関手は、型 <code>A</code> の値を <code>Option</code> で包んで型 <code>Option[A]</code> に変換します。また、関数 <code>A =&gt; B</code> を関数 <code>Option[A] =&gt; Option[B]</code> に変換します。</p>
<p>同様に、List 関手は型 <code>A</code> を <code>List[A]</code> に変換し、関数 <code>A =&gt; B</code> を <code>List[A] =&gt; List[B]</code> に変換します。Writer 関手も型 <code>A</code> を <code>Writer[A]</code> に変換し、関数 <code>A =&gt; B</code> を <code>Writer[A] =&gt; Writer[B]</code> に変換します。</p>
<p>圏は対象と射から構成されるので、圏を変換するには対象と射それぞれに関する対応を定義する必要があります。</p>
<p><img src="images/07_functor.png" alt="関手"></p>
<h3 id="711-対象関数">7.1.1 対象関数</h3>
<p>関手において、ある圏の対象を別のある圏の対象に変換するような対応を対象関数といいます。一般に、圏 <strong>C</strong> から <strong>D</strong> への関手 F は、圏 <strong>C</strong> の対象 a を <strong>D</strong> の対象 F(a) に対応させます。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 対象関数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">obj</span></span>[<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] = ???
</code></pre>
<p>Option 関手の例で言うと、Option 関手は型 <code>A</code> を型 <code>Option[A]</code> に対応させています。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objOptFunc</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">Option</span>(_)

objOptFunc(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res1: Option[Int] = Some(value = 3)</span>
objOptFunc(<span class="hljs-string">&quot;Hoge&quot;</span>)
<span class="hljs-comment">// res2: Option[String] = Some(value = &quot;Hoge&quot;)</span>
</code></pre>
<h3 id="712-射関数">7.1.2 射関数</h3>
<p>関手において、ある圏の射を別のある圏の射に変換するような対応を射関数といいます。一般に、圏 <strong>C</strong> から <strong>D</strong> への関手 F の射関数 <code>fmap</code> は、圏 <strong>C</strong> の射 f: a -&gt; b を <strong>D</strong> の射 F(f): F(a) -&gt; F(b)  に対応させます。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 射関数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]) = ???
</code></pre>
<p>例えば、Option 関手においては、射 <code>f: A =&gt; B</code> を <code>fmap(f): Option[A] =&gt; Option[B]</code> に対応させる必要があります。この対応は、標準ライブラリにある <code>Option#map</code> メソッドによって実現されます：</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmapOptFunc</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]) =
  f =&gt; optA =&gt; optA.map(f)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEven</span></span>: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Boolean</span> = n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">negate</span></span>: <span class="hljs-type">Boolean</span> =&gt; <span class="hljs-type">Boolean</span> = b =&gt; !b

fmapOptFunc(isEven)(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res3: Option[Boolean] = Some(value = false)</span>

fmapOptFunc(isEven)(<span class="hljs-type">Option</span>(<span class="hljs-number">4</span>))
<span class="hljs-comment">// res4: Option[Boolean] = Some(value = true)</span>

fmapOptFunc(negate)(<span class="hljs-type">Option</span>(<span class="hljs-literal">true</span>))
<span class="hljs-comment">// res5: Option[Boolean] = Some(value = false)</span>

fmapOptFunc(negate)(<span class="hljs-type">Option</span>(<span class="hljs-literal">false</span>))
<span class="hljs-comment">// res6: Option[Boolean] = Some(value = true)</span>
</code></pre>
<p><img src="images/07_option_functor.png" alt="Option 関手"></p>
<p>この射関数が満たすべき性質として、以下の2つがあります：</p>
<ol>
<li><strong>C</strong> の射 f, g の合成 <code>g compose f</code> について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li>C の任意の対象 A の恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) === identity[F[A]]</code> が成り立つこと。</li>
</ol>
<p>1つ目の性質は、関手が射の合成を保存することを意味します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> hamcat.util.<span class="hljs-type">Eq</span>.===

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span> = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span></span>[<span class="hljs-type">B</span>, <span class="hljs-type">C</span>]: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span> = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert1</span></span>[<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>] = fmap[<span class="hljs-type">F</span>, <span class="hljs-type">A</span>, <span class="hljs-type">C</span>](g[<span class="hljs-type">B</span>, <span class="hljs-type">C</span>].compose(f[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>])) === fmap[<span class="hljs-type">F</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](g[<span class="hljs-type">B</span>, <span class="hljs-type">C</span>]).compose(fmap[<span class="hljs-type">F</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]))
</code></pre>
<p>Option 関手の場合、満たされることが確認できます。</p>
<pre><code class="lang-scala">fmapOptFunc(negate.compose(isEven))(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res7: Option[Boolean] = Some(value = true)</span>

(fmapOptFunc(negate).compose(fmapOptFunc(isEven)))(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res8: Option[Boolean] = Some(value = true)</span>

fmapOptFunc(negate.compose(isEven))(<span class="hljs-type">Option</span>(<span class="hljs-number">4</span>))
<span class="hljs-comment">// res9: Option[Boolean] = Some(value = false)</span>

(fmapOptFunc(negate).compose(fmapOptFunc(isEven)))(<span class="hljs-type">Option</span>(<span class="hljs-number">4</span>))
<span class="hljs-comment">// res10: Option[Boolean] = Some(value = false)</span>
</code></pre>
<p><img src="images/07_functor_composition.png" alt="合成の保存"></p>
<p>射関数の2つ目の性質は、関手が恒等射を保存することを意味します。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert2</span></span>[<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>] = fmap[<span class="hljs-type">F</span>, <span class="hljs-type">A</span>, <span class="hljs-type">A</span>](identity[<span class="hljs-type">A</span>]) === identity[<span class="hljs-type">F</span>[<span class="hljs-type">A</span>]]
</code></pre>
<p>Option 関手の場合、満たされることが確認できます。</p>
<pre><code class="lang-scala">fmapOptFunc(identity[<span class="hljs-type">Int</span>])(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res11: Option[Int] = Some(value = 3)</span>

identity[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]](<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res12: Option[Int] = Some(value = 3)</span>
</code></pre>
<p>以上の性質は、圏の構造を保存する対応を表す性質です。このような2つの性質を<strong>関手性</strong> (functor laws) と呼びます。</p>
<h3 id="713-関手の定義">7.1.3 関手の定義</h3>
<p>では、関手の定義を与えましょう。一般に、関手は以下のように定義されます。</p>
<hr>
<p>圏 <strong>C</strong> から圏 <strong>D</strong> への<strong>関手</strong> (functor) <code>F</code> とは、以下を満たす対応のことです。</p>
<ul>
<li><strong>C</strong> の射 f: a -&gt; b を D の射 F(f): F(a) -&gt; F(b) すなわち <code>fmap(f): F[A] =&gt; F[B]</code> に対応させること。</li>
<li><strong>C</strong> の射 f, g の合成 <code>g compose f</code> について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li><strong>C</strong> の任意の対象 A の恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) == identity[F[A]]</code> が成り立つこと。</li>
</ul>
<hr>
<p>先ほどみたように、2 番目と 3 番目は関手性を表します。</p>
<p>なお、圏 <strong>C</strong> と <strong>D</strong> は同じであってもよく、特に圏 <strong>C</strong> から圏 <strong>C</strong> への関手は<strong>自己関手</strong> (endofunctor) と呼ばれます。Scala 圏における関手は全て、自己関手です。</p>
<h2 id="72-プログラミングにおける関手">7.2 プログラミングにおける関手</h2>
<p>前節では、関手の定義を与えました。本節では、Scala プログラミングにおける関手を考えていきます。</p>
<h3 id="721-functor-型クラス">7.2.1 Functor 型クラス</h3>
<p>関手は Scala において、以下のような型クラス <a href="https://github.com/taretmch/hamcat/blob/master/src/main/scala/data/Functor.scala" target="_blank">Functor</a> として実装できます。<code>Functor</code> 型クラスは、対象関数として型構築子 <code>F[_]</code> をもち、射関数として <code>fmap</code> メソッドを持ちます。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Functor</span>[<span class="hljs-type">F</span>[_]]</span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
</code></pre>
<p><code>fmap</code> メソッドは関数を<strong>引き上げる</strong> (lift)、とも言われます。関数 <code>A =&gt; B</code> は <code>fmap</code> によって <code>F[_]</code> 上の関数 <code>F[A] =&gt; F[B]</code> に引き上げられます。</p>
<h3 id="722-option-関手">7.2.2 Option 関手</h3>
<p>ある型 <code>F[_]</code> に対する <code>Functor</code> のインスタンスを実装してみましょう。ここでは、<code>Option</code> についての <code>Functor</code> のインスタンスを定義します。</p>
<p><code>Option</code> 型に対する <code>Functor</code> のインスタンスは、以下のように実装できます。<code>Functor</code> に必要なパラメータは型構築子としての <code>Option</code> です。また、抽象メソッドである射関数 <code>fmap</code> を実装する必要があります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = _.map(f)
</code></pre>
<p>Option 関手の <code>fmap</code> メソッドは <code>Option#map</code> メソッドと同じです。実装を見てわかる通り、<code>fmap</code> メソッドが関手性を満たすかどうか、つまり圏の構造を維持する対応かどうかは実装によります。定義だけでは <code>fmap</code> メソッドが必ず関手性を満たすとは言えませんが、関手性を満たすように <code>fmap</code> メソッドを実装しなければいけません。</p>
<p>実際にこのインスタンスを使ってみましょう。<code>fmap</code> に <code>Option(3)</code> と <code>isEven</code> (偶数かどうかを判定する関数) を与えると、<code>Option(3)</code> の中の値に <code>isEven</code> を適用した結果 (すなわち <code>Some(false)</code>) が出力されます。</p>
<pre><code class="lang-scala">summon[<span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>]].fmap(isEven)(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res13: Option[Boolean] = Some(value = false)</span>

summon[<span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>]].fmap(isEven)(<span class="hljs-type">Option</span>(<span class="hljs-number">4</span>))
<span class="hljs-comment">// res14: Option[Boolean] = Some(value = true)</span>
</code></pre>
<p>なお、毎回 <code>summon[Functor[Option]].fmap(...)</code> と書くのは面倒ですし、不便です。この場合、以下のように拡張メソッドを定義することによって <code>Option#fmap</code> メソッドとして呼び出せるようになります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">extension</span> [<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(<span class="hljs-keyword">using</span> functor: <span class="hljs-type">Functor</span>[<span class="hljs-type">F</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>] =
    functor.fmap[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f)(fa)
</code></pre>
<pre><code class="lang-scala"><span class="hljs-type">Option</span>(<span class="hljs-number">3</span>).fmap(isEven)
<span class="hljs-comment">// res15: Option[Boolean] = Some(value = false)</span>

<span class="hljs-type">Option</span>(<span class="hljs-number">4</span>).fmap(isEven)
<span class="hljs-comment">// res16: Option[Boolean] = Some(value = true)</span>
</code></pre>
<p>では、この Option 関手の <code>fmap</code> メソッドが関手性を満たすかどうかについて調べてみましょう。</p>
<p>関手性とは、以下が成り立つことでした。</p>
<ul>
<li><strong>C</strong> の射 f, g の合成 <code>g compose f</code> について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li><strong>C</strong> の任意の対象 A の恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) == identity[F[A]]</code> が成り立つこと。</li>
</ul>
<p><code>isEven</code> 関数と <code>negate</code> 関数を使ってこちらを確認してみます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> optionFunctor = summon[<span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>]]
<span class="hljs-comment">// optionFunctor: given_Functor_Option = repl.MdocSession$MdocApp0$given_Functor_Option$@e68810b</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">negate</span></span>(b: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Boolean</span> = !b

<span class="hljs-comment">// fmap(g compose f) == fmap(g) compose fmap(f) の確認</span>
optionFunctor.fmap(negate compose isEven)(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res17: Option[Boolean] = Some(value = true)</span>

optionFunctor.fmap(negate).compose(optionFunctor.fmap(isEven))(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res18: Option[Boolean] = Some(value = true)</span>

<span class="hljs-comment">// fmap(identity[A]) == identity[F[A]] の確認</span>
optionFunctor.fmap(identity[<span class="hljs-type">Int</span>])(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res19: Option[Int] = Some(value = 3)</span>

identity[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]](<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res20: Option[Int] = Some(value = 3)</span>
</code></pre>
<h3 id="723-reader-関手">7.2.3 Reader 関手</h3>
<p>次の例として、型 <code>A</code> を受け取ったとき、任意の型 <code>R</code> を受け取って <code>A</code> を返すような関数 <code>R =&gt; A</code> に変換するような関手を考えます。この関手は Reader 関手と呼ばれます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>](<span class="hljs-params">run: <span class="hljs-type">R</span> =&gt; <span class="hljs-type">A</span></span>)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objReaderFunctor</span></span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>](f: <span class="hljs-type">R</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>](f)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmapReaderFunctor</span></span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">B</span>] = fa =&gt;
  <span class="hljs-type">Reader</span>(fa.run.andThen(f))
</code></pre>
<p><code>R =&gt; A</code> という表記は関数であり、Scala においては1変数関数の型 <code>Function1[R, A]</code> であることがわかります。</p>
<p>すなわち、Reader の対応が関手であるということは、関数も関手であるといえます。関数が関手であれば、型 <code>R</code> を受け取って <code>A</code> を返すような関数 <code>R =&gt; A</code> があったとき、<code>A</code> を <code>B</code> に変換する関数 <code>f: A =&gt; B</code> を与えれば <code>R</code> から <code>B</code> の関数を取得することができます。</p>
<p>Reader 関手のインスタンスは、以下のように実装できます。対象関数は型構築子 <code>[X] =&gt;&gt; Reader[R, X]</code>、射関数 <code>fmap</code> は関数合成です。ここで、<code>[X] =&gt;&gt; Reader[R, X]</code> の表記は Scala 3 の Type Lambda というもので、<code>R =&gt; X</code> を表します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> [<span class="hljs-type">R</span>]: <span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">B</span>] = fa =&gt;
    <span class="hljs-type">Reader</span>(fa.run.andThen(f))
</code></pre>
<p>これを使うと、例えば以下のようなことができます。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">Reader</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>], <span class="hljs-type">Int</span>] = <span class="hljs-type">Reader</span>(_.length)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greaterThanZero</span></span>: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Boolean</span> = _ &gt; <span class="hljs-number">0</span>

<span class="hljs-comment">// List[A] =&gt; Int を List[A] =&gt; Boolean に変換する</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nonEmpty</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">Reader</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>], <span class="hljs-type">Boolean</span>] = length.fmap(greaterThanZero)

nonEmpty.run(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))
<span class="hljs-comment">// res21: Boolean = true</span>

nonEmpty.run(<span class="hljs-type">List</span>.empty[<span class="hljs-type">Int</span>])
<span class="hljs-comment">// res22: Boolean = false</span>
</code></pre>
<p>関数合成 (<code>andThen</code>, <code>compose</code>) が Reader 関手の射関数であるのですね。</p>
<h3 id="724-writer-関手">7.2.4 Writer 関手</h3>
<p>4章で、Kleisli 圏の例として Writer 圏を見ました。Writer 圏において、以下のような型 <code>Writer</code> を導入しました。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> hamcat.<span class="hljs-type">Semigroup</span>
<span class="hljs-keyword">import</span> hamcat.<span class="hljs-type">Monoid</span>
<span class="hljs-keyword">import</span> hamcat.syntax.semigroup.*

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>](<span class="hljs-params">run: (<span class="hljs-type">L</span>, <span class="hljs-type">A</span></span>))</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Writer</span></span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>)(<span class="hljs-keyword">using</span> m: <span class="hljs-type">Monoid</span>[<span class="hljs-type">L</span>]): <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">Writer</span>((m.empty, a))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&gt;=&gt;</span></span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](<span class="hljs-keyword">using</span> <span class="hljs-type">Semigroup</span>[<span class="hljs-type">L</span>]): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">B</span>]) =&gt; (<span class="hljs-type">B</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">C</span>]) =&gt; (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">C</span>]) = f =&gt; g =&gt; a =&gt;
    <span class="hljs-keyword">val</span> (logF, b) = f(a).run
    <span class="hljs-keyword">val</span> (logG, c) = g(b).run
    <span class="hljs-type">Writer</span>((logF |+| logG), c)

<span class="hljs-keyword">extension</span> [<span class="hljs-type">L</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">B</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">&gt;=&gt;</span></span>[<span class="hljs-type">C</span>](<span class="hljs-keyword">using</span> <span class="hljs-type">Semigroup</span>[<span class="hljs-type">L</span>])(g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">C</span>]): <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">C</span>] =
    <span class="hljs-type">Writer</span>.&gt;=&gt;(f)(g)
</code></pre>
<p>Writer 圏における対象は任意の型 <code>A</code> で、<code>A</code> から <code>A</code> への射は <code>A =&gt; Writer[L, A]</code> だと定義しました。</p>
<p>実は、Writer 圏における射の合成をうまく活用することによって、<code>Writer</code> についての <code>fmap</code> メソッドを実装することができます。そのため、<code>Writer</code> は関手であって、Writer 関手と呼ばれます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> [<span class="hljs-type">L</span>](<span class="hljs-keyword">using</span> m: <span class="hljs-type">Monoid</span>[<span class="hljs-type">L</span>]): <span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">X</span>]] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">B</span>] =
    identity[<span class="hljs-type">Writer</span>[<span class="hljs-type">L</span>, <span class="hljs-type">A</span>]] &gt;=&gt; (a =&gt; <span class="hljs-type">Writer</span>.pure[<span class="hljs-type">L</span>, <span class="hljs-type">B</span>](f(a)))
</code></pre>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Monoid</span>[<span class="hljs-type">String</span>] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>): <span class="hljs-type">String</span> = a + b
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span></span>: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span>

<span class="hljs-keyword">val</span> stringWriterFunctor = summon[<span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Writer</span>[<span class="hljs-type">String</span>, <span class="hljs-type">X</span>]]]
<span class="hljs-comment">// stringWriterFunctor: given_Functor_Writer[String] = repl.MdocSession$MdocApp0$given_Functor_Writer@6a3238e3</span>
<span class="hljs-keyword">val</span> intWriter = <span class="hljs-type">Writer</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>](<span class="hljs-string">&quot;hogehoge. &quot;</span>, <span class="hljs-number">12345</span>)
<span class="hljs-comment">// intWriter: Writer[String, Int] = Writer(run = (&quot;hogehoge. &quot;, 12345))</span>
<span class="hljs-keyword">val</span> double: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = _ * <span class="hljs-number">2</span>
<span class="hljs-comment">// double: Function1[Int, Int] = repl.MdocSession$MdocApp0$$Lambda/0x00007f84f229f1b0@31dccb1d</span>
stringWriterFunctor.fmap(double)(intWriter)
<span class="hljs-comment">// res23: Writer[String, Int] = Writer(run = (&quot;hogehoge. &quot;, 24690))</span>

<span class="hljs-keyword">val</span> listWriter = <span class="hljs-type">Writer</span>[<span class="hljs-type">String</span>, <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]](<span class="hljs-string">&quot;hogehoge. &quot;</span>, <span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))
<span class="hljs-comment">// listWriter: Writer[String, List[Int]] = Writer(</span>
<span class="hljs-comment">//   run = (&quot;hogehoge. &quot;, List(1, 2, 3, 4, 5))</span>
<span class="hljs-comment">// )</span>
<span class="hljs-keyword">val</span> listLength: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] =&gt; <span class="hljs-type">Int</span> = _.length
<span class="hljs-comment">// listLength: Function1[List[Int], Int] = repl.MdocSession$MdocApp0$$Lambda/0x00007f84f22a0f88@7a6a1863</span>
stringWriterFunctor.fmap(listLength)(listWriter)
<span class="hljs-comment">// res24: Writer[String, Int] = Writer(run = (&quot;hogehoge. &quot;, 5))</span>
</code></pre>
<h2 id="73-関手の合成">7.3 関手の合成</h2>
<p>さて、圏を対象として関手を射とするような圏を考えるとき、射の合成、すなわち関手の合成を定義する必要があります。</p>
<p>Scala 圏における関手は全て自己関手なので、自己関手同士を合成することができるのかどうかについて考えてみましょう。</p>
<p>例えば、2つの関手 Option 関手と Reader 関手を合成してみるとどうなるでしょうか。関手の合成に関しても、対象関数の合成と射関数の合成を考える必要がありそうです。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 対象関数の合成</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderOption</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>](<span class="hljs-params">run: <span class="hljs-type">R</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]</span>)</span>

<span class="hljs-keyword">val</span> toIntOption: <span class="hljs-type">ReaderOption</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">ReaderOption</span>(_.toIntOption)
<span class="hljs-comment">// toIntOption: ReaderOption[String, Int] = ReaderOption(</span>
<span class="hljs-comment">//   run = repl.MdocSession$MdocApp0$$Lambda/0x00007f84f22a1780@8eeb4cb</span>
<span class="hljs-comment">// )</span>

toIntOption.run(<span class="hljs-string">&quot;12345&quot;</span>)
<span class="hljs-comment">// res25: Option[Int] = Some(value = 12345)</span>

toIntOption.run(<span class="hljs-string">&quot;hoge&quot;</span>)
<span class="hljs-comment">// res26: Option[Int] = None</span>
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">// 射関数の合成</span>
<span class="hljs-keyword">given</span> [<span class="hljs-type">R</span>](<span class="hljs-keyword">using</span> readerF: <span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]], optionF: <span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>]): <span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">ReaderOption</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">ReaderOption</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">ReaderOption</span>[<span class="hljs-type">R</span>, <span class="hljs-type">B</span>] = fa =&gt;
    <span class="hljs-type">ReaderOption</span>(readerF.fmap(optionF.fmap(f))(<span class="hljs-type">Reader</span>[<span class="hljs-type">R</span>, <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]](fa.run)).run)

toIntOption.fmap(_ * <span class="hljs-number">2</span>).run(<span class="hljs-string">&quot;12345&quot;</span>)
<span class="hljs-comment">// res27: Option[Int] = Some(value = 24690)</span>

toIntOption.fmap(_ * <span class="hljs-number">2</span>).run(<span class="hljs-string">&quot;hoge&quot;</span>)
<span class="hljs-comment">// res28: Option[Int] = None</span>
</code></pre>
<p>自然と関手を定義してしまいましたが、関手の合成によって定義された射関数は、射の合成を保存しています。また、恒等射も保存します。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// fmap(g compose f) == fmap(g) compose fmap(f)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert3</span></span>[<span class="hljs-type">R</span>] =
  <span class="hljs-keyword">val</span> f = summon[<span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">ReaderOption</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]]]
  f.fmap(negate.compose(isEven)) === f.fmap(negate).compose(f.fmap(isEven))

<span class="hljs-keyword">val</span> readerOptionFunctor = summon[<span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">ReaderOption</span>[<span class="hljs-type">String</span>, <span class="hljs-type">X</span>]]]
<span class="hljs-comment">// readerOptionFunctor: given_Functor_ReaderOption[String] = repl.MdocSession$MdocApp0$given_Functor_ReaderOption@f013d</span>

(readerOptionFunctor.fmap(negate.compose(isEven))(<span class="hljs-type">ReaderOption</span>(_.toIntOption))).run(<span class="hljs-string">&quot;12345&quot;</span>)
<span class="hljs-comment">// res29: Option[Boolean] = Some(value = true)</span>

(readerOptionFunctor.fmap(negate).compose(readerOptionFunctor.fmap(isEven))(<span class="hljs-type">ReaderOption</span>(_.toIntOption))).run(<span class="hljs-string">&quot;12345&quot;</span>)
<span class="hljs-comment">// res30: Option[Boolean] = Some(value = true)</span>

<span class="hljs-comment">// fmap(identity[A]) == identity[F[A]]</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert4</span></span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>] =
  <span class="hljs-keyword">val</span> f = summon[<span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">ReaderOption</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]]]
  f.fmap(identity[<span class="hljs-type">A</span>]) === identity[<span class="hljs-type">ReaderOption</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>]]

((readerOptionFunctor.fmap(identity[<span class="hljs-type">Int</span>]))(<span class="hljs-type">ReaderOption</span>(_.toIntOption))).run(<span class="hljs-string">&quot;12345&quot;</span>)
<span class="hljs-comment">// res31: Option[Int] = Some(value = 12345)</span>

(identity[<span class="hljs-type">ReaderOption</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]](<span class="hljs-type">ReaderOption</span>(_.toIntOption))).run(<span class="hljs-string">&quot;12345&quot;</span>)
<span class="hljs-comment">// res32: Option[Int] = Some(value = 12345)</span>
</code></pre>
<p>したがって、関手の合成もまた、関手であることがわかります。</p>
<p>自己関手の場合のみを取り上げましたが、自己関手でない一般の関手に関してもこれは成り立ちます。興味があれば証明してみてください。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>関手は、ある圏を、構造を維持しながら別のある圏に変換する対応のこと。<ul>
<li>関手の例として、Option、List、Reader などがある。</li>
<li>関手は、対象 A を対象 F[A] に対応させる。</li>
<li>関手は、射 <code>f: A =&gt; B</code> を射 <code>fmap(f): F[A] =&gt; F[B]</code> に対応させる。</li>
</ul>
</li>
<li>関手が満たす以下の性質のことを、関手性と呼ぶ。<ul>
<li>射 f, g の合成 g . f について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li>恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) == identity[F[A]]</code> が成り立つこと。</li>
</ul>
</li>
<li>Reader 関手は、ある型 <code>A</code> に対して、<code>A</code> を返す任意の関数 <code>Function1[*, A]</code> を対応させる関手である。</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="08_Functoriality.html" class="navigation navigation-next navigation-unique" aria-label="Next page: 8章 関手性">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"圏論の勉強記録です。本章では、圏から圏への対応である関手について定義し、プログラミングにおける関手の例（Option 関手や Reader 関手）を示します。","title":"7章 関手","level":"1.2.7","depth":2,"next":{"title":"8章 関手性","level":"1.2.8","depth":2,"path":"08_Functoriality.md","ref":"08_Functoriality.md","articles":[]},"previous":{"title":"6章 代数的データ型（一部は5章に）","level":"1.2.6","depth":2,"ref":"","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./mdoc-output","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"taretmch","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Scala で始める圏論入門","language":"ja","gitbook":"*","description":"本サイトは、圏論初心者が圏論について学びながら作成した、Scala プログラマのための入門書です。教科書は Bartosz Milewski 氏著の Category Theory for Programmers の Scala Edition で、構成も原則これに沿っています。Scala をやっていて、圏論について知りたい・学ぶ土台を作りたいという方の参考になれば幸いです。"},"file":{"path":"07_Functor.md","mtime":"2024-07-02T15:17:29.896Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-07-02T15:17:34.757Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

