
<!DOCTYPE HTML>
<html lang="ja" >
    <head>
        <meta charset="UTF-8">
        <title>7章 関手 · Scala で始める圏論入門</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="圏論の勉強記録です。本章では、圏から圏への対応である関手について定義し、プログラミングにおける関手の例（Option 関手や Reader 関手）を示します。">
        <meta name="generator" content="HonKit 5.1.4">
        <meta name="author" content="taretmch">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="08_Functoriality.html" />
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="検索ワードを入力" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    はじめに
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    第1部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="01_Category.html">
            
                <a href="01_Category.html">
            
                    
                    1章 圏とは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="02_Types_and_functions.html">
            
                <a href="02_Types_and_functions.html">
            
                    
                    2章 型と関数の圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="03_Categories_great_and_small.html">
            
                <a href="03_Categories_great_and_small.html">
            
                    
                    3章 いろいろな圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="04_Kleisli_category.html">
            
                <a href="04_Kleisli_category.html">
            
                    
                    4章 Kleisli圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="05_Products_and_Coproducts.html">
            
                <a href="05_Products_and_Coproducts.html">
            
                    
                    5, 6章 積と余積
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" >
            
                <span>
            
                    
                    6章 代数的データ型（一部は5章に）
            
                </span>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.7" data-path="07_Functor.html">
            
                <a href="07_Functor.html">
            
                    
                    7章 関手
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="08_Functoriality.html">
            
                <a href="08_Functoriality.html">
            
                    
                    8章 関手性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" >
            
                <span>
            
                    
                    （工事中）9章 関数型
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10_Natural_transformations.html">
            
                <a href="10_Natural_transformations.html">
            
                    
                    10章 自然変換
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    第2部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    （工事中）11章 宣言型プログラミング
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="12_Limits_and_Colimits.html">
            
                <a href="12_Limits_and_Colimits.html">
            
                    
                    12章 極限と余極限
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    付録
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="00_Notation.html">
            
                <a href="00_Notation.html">
            
                    
                    表記法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="tips/08_2_Writer_Functor.html">
            
                <a href="tips/08_2_Writer_Functor.html">
            
                    
                    Writer 圏における射の合成と、恒等射と、関手について
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            HonKitで公開 
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >7章 関手</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <!-- omit in toc -->
<h1 id="7-関手">7. 関手</h1>
<p>圏は対象の集まりと射の集まりからなりますが、これまでに何度か「対象を圏として圏を構成できるのではないか？」と思った人もいるのではないでしょうか。</p>
<p>その疑問に対する答えは「できる」です。今回定義する関手を使えば、圏の構造（つまり、圏の図式の形）を維持したまま別の圏に変換できるようになります。</p>
<p>関手は、非常に単純ですが強力な概念です。本章では、関手とは何かについて定義し、プログラミングにおける関手の例を示します。</p>
<!-- omit in toc -->
<h1 id="目次">目次</h1>
<ul>
<li><a href="#71-関手とは">7.1 関手とは</a><ul>
<li><a href="#711-対象関数">7.1.1 対象関数</a></li>
<li><a href="#712-射関数">7.1.2 射関数</a></li>
<li><a href="#713-関手の定義">7.1.3 関手の定義</a></li>
</ul>
</li>
<li><a href="#72-プログラミングにおける関手">7.2 プログラミングにおける関手</a><ul>
<li><a href="#721-functor-型クラス">7.2.1 Functor 型クラス</a></li>
<li><a href="#722-option-関手">7.2.2 Option 関手</a></li>
<li><a href="#723-reader-関手">7.2.3 Reader 関手</a></li>
</ul>
</li>
<li><a href="#73-関手の合成">7.3 関手の合成</a></li>
<li><a href="#まとめ">まとめ</a></li>
</ul>
<h2 id="71-関手とは">7.1 関手とは</h2>
<p><strong>関手</strong> (functor) は、ある圏 <strong>C</strong> を別のある圏 <strong>D</strong> に変換する対応 F のことです。</p>
<p>関手の例としては Option 関手、List 関手、Writer 関手、モノイド準同型などがあります。モノイド準同型は、モノイド間の関手です。</p>
<p>Option 関手は、型 <code>A</code> の値を <code>Option</code> で包んで型 <code>Option[A]</code> に変換します。また、関数 <code>A =&gt; B</code> を関数 <code>Option[A] =&gt; Option[B]</code> に変換します。</p>
<p>同様に、List 関手は型 <code>A</code> を <code>List[A]</code> に変換し、関数 <code>A =&gt; B</code> を <code>List[A] =&gt; List[B]</code> に変換します。Writer 関手も型 <code>A</code> を <code>Writer[A]</code> に変換し、関数 <code>A =&gt; B</code> を <code>Writer[A] =&gt; Writer[B]</code> に変換します。</p>
<p>圏は対象と射から構成されるので、圏を変換するには対象と射それぞれに関する対応を定義する必要があります。</p>
<p><img src="images/07_functor.png" alt="関手"></p>
<h3 id="711-対象関数">7.1.1 対象関数</h3>
<p>関手において、ある圏の対象を別のある圏の対象に変換するような対応を対象関数といいます。一般に、圏 <strong>C</strong> から <strong>D</strong> への関手 F は、圏 <strong>C</strong> の対象 a を <strong>D</strong> の対象 F(a) に対応させます。</p>
<p>Option 関手の例で言うと、Option 関手は型 <code>A</code> を型 <code>Option[A]</code> に対応させています。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objOptFunc</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">A</span> =&gt;  <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">Option</span>(_)

objOptFunc(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res0: Option[Int] = Some(value = 3)</span>
objOptFunc(<span class="hljs-string">&quot;Hoge&quot;</span>)
<span class="hljs-comment">// res1: Option[String] = Some(value = &quot;Hoge&quot;)</span>
</code></pre>
<h3 id="712-射関数">7.1.2 射関数</h3>
<p>関手において、ある圏の射を別のある圏の射に変換するような対応を射関数といいます。一般に、圏 <strong>C</strong> から <strong>D</strong> への関手 F の射関数は、圏 <strong>C</strong> の射 f: a -&gt; b を <strong>D</strong> の射 F(f): F(a) -&gt; F(b) に対応させます。Hamcat において、射関数は <code>fmap</code> メソッドとして定義しています。</p>
<p>Option 関手は、例で言うと、射 <code>f: A =&gt; B</code> を <code>fmap(f): Option[A] =&gt; Option[B]</code> に対応させる必要があります。この対応は、標準ライブラリにある <code>Option#map</code> メソッドによって実現されます：</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEven</span></span>: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Boolean</span> = n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">negate</span></span>: <span class="hljs-type">Boolean</span> =&gt; <span class="hljs-type">Boolean</span> = b =&gt; !b

<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>).map(isEven)
<span class="hljs-comment">// res2: Option[Boolean] = Some(value = false)</span>
<span class="hljs-type">Option</span>(<span class="hljs-literal">true</span>).map(negate)
<span class="hljs-comment">// res3: Option[Boolean] = Some(value = false)</span>
</code></pre>
<p><img src="images/07_option_functor.png" alt="Option 関手"></p>
<p>この射関数が満たすべき性質として、以下の2つがあります：</p>
<ol>
<li><strong>C</strong> の射 f, g の合成 <code>g compose f</code> について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li>C の任意の対象 A の恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) === identity[F[A]]</code> が成り立つこと。</li>
</ol>
<p>1つ目の性質は、関手が射の合成を保存することを意味します。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// hamcat における関手のデータ型、インスタンスをインポート</span>
<span class="hljs-keyword">import</span> hamcat.util.<span class="hljs-type">Eq</span>.===

<span class="hljs-comment">// Option 型に対する Functor のインスタンス</span>
<span class="hljs-keyword">val</span> optionFunctor = summon[<span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>]]
<span class="hljs-comment">// optionFunctor: Functor[[A &gt;: Nothing &lt;: Any] =&gt;&gt; Option[A]] = repl.MdocSession$MdocApp$$anon$20@43100d0b</span>

<span class="hljs-comment">// f: isEven, g: negate とします</span>
<span class="hljs-comment">// fmap(g compose f)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifted1</span> </span>= optionFunctor.fmap(negate.compose(isEven))

<span class="hljs-comment">// fmap(g) compose fmap(f)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifted2</span> </span>= optionFunctor.fmap(negate).compose(optionFunctor.fmap(isEven))

<span class="hljs-comment">// 射の合成が保存されることの確認</span>
lifted1 === lifted2
<span class="hljs-comment">// res4: Eq2[Function1[Option[Int], Option[Boolean]]] = Eq2(</span>
<span class="hljs-comment">//   lhs = repl.MdocSession$MdocApp$$anon$20$$Lambda/0x00007fcf6e282000@279f96af,</span>
<span class="hljs-comment">//   rhs = scala.Function1$$Lambda/0x00007fcf6d41b640@23e7e611</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>例えば、<code>Option(3)</code> に対して以下が成り立ちます。</p>
<pre><code class="lang-scala">optionFunctor.fmap(negate compose isEven)(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>)) == (optionFunctor.fmap(negate) compose optionFunctor.fmap(isEven))(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res5: Boolean = true</span>
</code></pre>
<p><img src="images/07_functor_composition.png" alt="合成の保存"></p>
<p>2つ目の性質は、関手が恒等射を保存することを意味します。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// fmap(identity[A])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifted3</span> </span>= optionFunctor.fmap(identity[<span class="hljs-type">Int</span>])

<span class="hljs-comment">// identity[F[A]]</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lifted4</span> </span>= identity[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]]

lifted3 === lifted4
<span class="hljs-comment">// res6: Eq2[Function1[Option[Int], Option[Int]]] = Eq2(</span>
<span class="hljs-comment">//   lhs = repl.MdocSession$MdocApp$$anon$20$$Lambda/0x00007fcf6e282000@fb4a197,</span>
<span class="hljs-comment">//   rhs = repl.MdocSession$MdocApp$$Lambda/0x00007fcf6e282bd8@51f0a97c</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>例えば、<code>Option(3)</code> に対して以下が成り立ちます。</p>
<pre><code class="lang-scala">optionFunctor.fmap(identity[<span class="hljs-type">Int</span>])(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>)) == identity[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]](<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res7: Boolean = true</span>
</code></pre>
<p>以上の性質は圏の構造を保存する対応を表す性質です。このような2つの性質を<strong>関手性</strong> (functor laws) と呼びます。</p>
<h3 id="713-関手の定義">7.1.3 関手の定義</h3>
<p>では、関手の定義を与えましょう。一般に、関手は以下のように定義されます。</p>
<hr>
<p>圏 <strong>C</strong> から圏 <strong>D</strong> への<strong>関手</strong> (functor) <code>F</code> とは、以下を満たす対応のことです。</p>
<ul>
<li><strong>C</strong> の射 f: a -&gt; b を D の射 F(f): F(a) -&gt; F(b) すなわち <code>fmap(f): F[A] =&gt; F[B]</code> に対応させること。</li>
<li><strong>C</strong> の射 f, g の合成 <code>g compose f</code> について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li><strong>C</strong> の任意の対象 A の恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) == identity[F[A]]</code> が成り立つこと。</li>
</ul>
<hr>
<p>先ほどみたように、2 番目と 3 番目は関手性を表します。</p>
<p>なお、圏 <strong>C</strong> と <strong>D</strong> は同じであってもよく、特に圏 <strong>C</strong> から圏 <strong>C</strong> への関手は<strong>自己関手</strong> (endofunctor) と呼ばれます。Scala 圏における関手は全て、自己関手です。</p>
<h2 id="72-プログラミングにおける関手">7.2 プログラミングにおける関手</h2>
<p>前節では、関手の定義を与えました。本節では、Scala プログラミングにおける関手を考えていきます。</p>
<h3 id="721-functor-型クラス">7.2.1 Functor 型クラス</h3>
<p>関手は Scala において、以下のような型クラス <a href="https://github.com/taretmch/hamcat/blob/master/src/main/scala/data/Functor.scala" target="_blank">Functor</a> として実装できます。<code>Functor</code> 型クラスは、対象関数として型構築子 <code>F[_]</code> をもち、射関数として <code>fmap</code> メソッドを持ちます。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Functor</span>[<span class="hljs-type">F</span>[_]]</span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
</code></pre>
<p><code>fmap</code> メソッドは関数を<strong>引き上げる</strong> (lift)、とも言われます。関数 <code>A =&gt; B</code> は <code>fmap</code> によって <code>F[_]</code> 上の関数 <code>F[A] =&gt; F[B]</code> に引き上げられます。</p>
<h3 id="722-option-関手">7.2.2 Option 関手</h3>
<p>ある型 <code>F[_]</code> に対する <code>Functor</code> のインスタンスを実装してみましょう。ここでは、<code>Option</code> についての <code>Functor</code> のインスタンスを定義します。</p>
<p>Option 型に対する <code>Functor</code> のインスタンスは、以下のように実装できます。<code>Functor</code> に必要なパラメータは型構築子としての <code>Option</code> です。また、抽象メソッドである射関数 <code>fmap</code> を実装する必要があります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>]:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = _.map(f)
</code></pre>
<p>Option 関手の <code>fmap</code> メソッドは <code>Option#map</code> メソッドと同じです。実装を見てわかる通り、<code>fmap</code> メソッドが関手性を満たすかどうか、つまり圏の構造を維持する対応かどうかは実装によります。定義だけでは <code>fmap</code> メソッドが必ず関手性を満たすとは言えませんが、関手性を満たすように <code>fmap</code> メソッドを実装しなければいけません。</p>
<p>実際にこのインスタンスを使ってみましょう。本リポジトリでは、型クラスのインスタンスは <code>hamcat.data.instance</code> パッケージ内においてあります。コンソールにおいて <code>hamcat.data.instance.Implicits.given</code> をインポートすれば、全てのインスタンスが使えるようになります。<code>fmap</code> に <code>Option(3)</code> と <code>isEven</code> (偶数かどうかを判定する関数) を与えると、<code>Option(3)</code> の中の値に <code>isEven</code> を適用した結果 (すなわち <code>Some(false)</code>) が出力されます。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// import hamcat.data.instance.Implicits.given 実行後</span>
summon[<span class="hljs-type">Functor</span>[<span class="hljs-type">Option</span>]].fmap(isEven)(<span class="hljs-type">Option</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res8: Option[Boolean] = Some(value = false)</span>
</code></pre>
<p>なお、毎回 <code>summon[Functor[Option]].fmap(...)</code> と書くのは面倒ですし、不便です。この場合、以下のように拡張メソッドを定義することによって <code>Option#fmap</code> メソッドとして呼び出せるようになります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">extension</span> [<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(<span class="hljs-keyword">using</span> functor: <span class="hljs-type">Functor</span>[<span class="hljs-type">F</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>] =
    functor.fmap[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f)(fa)
</code></pre>
<pre><code class="lang-scala"><span class="hljs-type">Option</span>(<span class="hljs-number">3</span>).fmap(isEven)
<span class="hljs-comment">// res9: Option[Boolean] = Some(value = false)</span>
</code></pre>
<p>では、この Option 関手の <code>fmap</code> メソッドが関手性を満たすかどうかについて調べてみましょう。</p>
<p>関手性とは、以下が成り立つことでした。</p>
<ul>
<li><strong>C</strong> の射 f, g の合成 <code>g compose f</code> について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li><strong>C</strong> の任意の対象 A の恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) == identity[F[A]]</code> が成り立つこと。</li>
</ul>
<h3 id="723-reader-関手">7.2.3 Reader 関手</h3>
<p>次の例として、型 <code>A</code> を受け取ったとき、任意の型 <code>X</code> を受け取って <code>A</code> を返すような関数 <code>X =&gt; A</code> に変換するような関手を考えます。この関手は Reader 関手と呼ばれます。</p>
<p>Reader 関手で重要なことは、関数も関手であるということです。関数が関手であれば、型 <code>R</code> を受け取って <code>A</code> を返すような関数 <code>R =&gt; A</code> があったとき、<code>A</code> を <code>B</code> に変換する関数 <code>f: A =&gt; B</code> を与えれば <code>R</code> から <code>B</code> の関数を取得することができます。</p>
<p>Reader 関手のインスタンスは、以下のように実装できます。対象関数として型構築子 <code>[X] =&gt;&gt; Function1[R, X]</code> を渡し、射関数 <code>fmap</code> を実装します。ここで、<code>Function1</code> は1変数関数を表す Scala 標準ライブラリの型です。<code>[X] =&gt;&gt; Function1[R, X]</code> は <code>R =&gt; X</code> を表します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> [<span class="hljs-type">R</span>]: <span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Function1</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]] = <span class="hljs-keyword">new</span> <span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Function1</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]]:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): (<span class="hljs-type">R</span> =&gt; <span class="hljs-type">A</span>) =&gt; (<span class="hljs-type">R</span> =&gt; <span class="hljs-type">B</span>) = fa =&gt;
    f.compose(fa)
</code></pre>
<p>なお、<code>[X] =&gt;&gt; Function1[R, X]</code> という記法は Scala 3 の Type Lambda というものです。</p>
<p><code>fmap</code> メソッドは、ただ2つの関数を合成しているだけです。関数 <code>R =&gt; A</code> があったとき、引数として関数 <code>A =&gt; B</code> を受け取ると関数 <code>R =&gt; B</code> が返されます。</p>
<p>これを使うと、例えば以下のようなことができます。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 偶数かどうか判定する関数を奇数かどうか判定する関数に変換する</span>
isEven.fmap(negate) (<span class="hljs-number">3</span>)
<span class="hljs-comment">// res10: Boolean = true</span>
</code></pre>
<p><code>compose</code> が関手の射関数であるのですね。</p>
<h2 id="73-関手の合成">7.3 関手の合成</h2>
<p>圏を対象として関手を射とするような圏を考えるとき、射の合成、すなわち関手の合成を定義する必要があります。</p>
<p>Scala 圏における関手は全て自己関手なので、自己関手同士を合成することができるのかどうかについて考えてみましょう。</p>
<p>例えば、2つの関手 Option と List を合成してみるとどうなるでしょうか。まず、List 型の関手としての実装は以下のようになります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Functor</span>[<span class="hljs-type">List</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Functor</span>[<span class="hljs-type">List</span>]:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] = _.map(f)
</code></pre>
<p>対象関数は、型 <code>Int</code> を Option 関手によって <code>Option[Int]</code> に変換し、List 関手によって <code>List[Option[Int]]</code> に変換するものとします。
`«§ﬂ</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> intOptionList: <span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">List</span>(<span class="hljs-type">Some</span>(<span class="hljs-number">1</span>), <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>), <span class="hljs-type">None</span>, <span class="hljs-type">Some</span>(<span class="hljs-number">4</span>))
<span class="hljs-comment">// intOptionList: List[Option[Int]] = List(</span>
<span class="hljs-comment">//   Some(value = 1),</span>
<span class="hljs-comment">//   Some(value = 3),</span>
<span class="hljs-comment">//   None,</span>
<span class="hljs-comment">//   Some(value = 4)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>次に、射関数は、List 関手の <code>fmap</code> メソッドと Option 関手の <code>fmap</code> メソッドの合成 <code>fmapC</code> と定義します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> listFunctor = summon[<span class="hljs-type">Functor</span>[<span class="hljs-type">List</span>]]
<span class="hljs-comment">// listFunctor: Functor[List] = repl.MdocSession$MdocApp$$anon$22@7e4c3f08</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmapL</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] = listFunctor.fmap
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmapO</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = optionFunctor.fmap

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmapC</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]] =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]] = fmapL.compose(fmapO[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>])
</code></pre>
<p>この <code>fmapC</code> メソッドを用いると、2つの関手によって包まれた型 <code>Int</code> 上の関数</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> increment: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = _ + <span class="hljs-number">1</span>
<span class="hljs-comment">// increment: Function1[Int, Int] = repl.MdocSession$MdocApp$$Lambda/0x00007fcf6e284c28@45047685</span>
</code></pre>
<p>を <code>List[Option[Int]]</code> 上の関数として引き上げることができます。</p>
<pre><code class="lang-scala">fmapC(increment)(intOptionList)
<span class="hljs-comment">// res11: List[Option[Int]] = List(</span>
<span class="hljs-comment">//   Some(value = 2),</span>
<span class="hljs-comment">//   Some(value = 4),</span>
<span class="hljs-comment">//   None,</span>
<span class="hljs-comment">//   Some(value = 5)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>これは、<code>fmap</code> メソッドを2回呼び出すことに等しいです。</p>
<pre><code class="lang-scala">intOptionList.fmap(_.fmap(increment))
<span class="hljs-comment">// res12: List[Option[Int]] = List(</span>
<span class="hljs-comment">//   Some(value = 2),</span>
<span class="hljs-comment">//   Some(value = 4),</span>
<span class="hljs-comment">//   None,</span>
<span class="hljs-comment">//   Some(value = 5)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>外側の <code>fmap</code> は List 関手の射関数で、内側の <code>fmap</code> は Option 関手の射関数です。</p>
<p>関手の合成によって定義された射関数 <code>fmapC</code> は射の合成を保存しますし、恒等射を保存します。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// fmap(g compose f) == fmap(g) compose fmap(f)</span>
fmapC(isEven compose increment)(intOptionList) == (fmapC(isEven) compose fmapC(increment))(intOptionList)
<span class="hljs-comment">// res13: Boolean = true</span>

<span class="hljs-comment">// fmap(identity[A]) == identity[F[A]]</span>
fmapC(identity[<span class="hljs-type">Int</span>])(intOptionList) == identity[<span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]]](intOptionList)
<span class="hljs-comment">// res14: Boolean = true</span>
</code></pre>
<p>したがって、関手の合成もまた、関手であることがわかります。</p>
<p>自己関手の場合のみを取り上げましたが、自己関手でない一般の関手に関してもこれは成り立ちます。興味があれば証明してみてください。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>関手は、ある圏を、構造を維持しながら別のある圏に変換する対応のこと。<ul>
<li>関手の例として、Option、List、Reader などがある。</li>
<li>関手は、対象 A を対象 F[A] に対応させる。</li>
<li>関手は、射 <code>f: A =&gt; B</code> を射 <code>fmap(f): F[A] =&gt; F[B]</code> に対応させる。</li>
</ul>
</li>
<li>関手が満たす以下の性質のことを、関手性と呼ぶ。<ul>
<li>射 f, g の合成 g . f について <code>fmap(g compose f) == fmap(g) compose fmap(f)</code> が成り立つこと。</li>
<li>恒等射 <code>identity[A]</code> について <code>fmap(identity[A]) == identity[F[A]]</code> が成り立つこと。</li>
</ul>
</li>
<li>Reader 関手は、ある型 <code>A</code> に対して、<code>A</code> を返す任意の関数 <code>Function1[*, A]</code> を対応させる関手である。</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="08_Functoriality.html" class="navigation navigation-next navigation-unique" aria-label="Next page: 8章 関手性">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"圏論の勉強記録です。本章では、圏から圏への対応である関手について定義し、プログラミングにおける関手の例（Option 関手や Reader 関手）を示します。","title":"7章 関手","level":"1.2.7","depth":2,"next":{"title":"8章 関手性","level":"1.2.8","depth":2,"path":"08_Functoriality.md","ref":"08_Functoriality.md","articles":[]},"previous":{"title":"6章 代数的データ型（一部は5章に）","level":"1.2.6","depth":2,"ref":"","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./mdoc-output","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"taretmch","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Scala で始める圏論入門","language":"ja","gitbook":"*","description":"本サイトは、圏論初心者が圏論について学びながら作成した、Scala プログラマのための入門書です。教科書は Bartosz Milewski 氏著の Category Theory for Programmers の Scala Edition で、構成も原則これに沿っています。Scala をやっていて、圏論について知りたい・学ぶ土台を作りたいという方の参考になれば幸いです。"},"file":{"path":"07_Functor.md","mtime":"2024-06-24T00:59:38.122Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-06-24T00:59:41.597Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

