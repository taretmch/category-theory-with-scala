
<!DOCTYPE HTML>
<html lang="ja" >
    <head>
        <meta charset="UTF-8">
        <title>8章 関手性 · Scala で始める圏論入門</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="圏論の勉強記録です。本章では、関手についてさらに深掘ります。Writer 関手や双関手、Reader 関手、反変関手、Profunctor、Hom 関手について学びます。">
        <meta name="generator" content="HonKit 5.1.4">
        <meta name="author" content="taretmch">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="07_Functor.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="検索ワードを入力" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    はじめに
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    第1部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="01_Category.html">
            
                <a href="01_Category.html">
            
                    
                    1章 圏とは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="02_Types_and_functions.html">
            
                <a href="02_Types_and_functions.html">
            
                    
                    2章 型と関数の圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="03_Categories_great_and_small.html">
            
                <a href="03_Categories_great_and_small.html">
            
                    
                    3章 いろいろな圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="04_Kleisli_category.html">
            
                <a href="04_Kleisli_category.html">
            
                    
                    4章 Kleisli圏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="05_Products_and_Coproducts.html">
            
                <a href="05_Products_and_Coproducts.html">
            
                    
                    5, 6章 積と余積
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" >
            
                <span>
            
                    
                    6章 代数的データ型（一部は5章に）
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="07_Functor.html">
            
                <a href="07_Functor.html">
            
                    
                    7章 関手
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.8" data-path="08_Functoriality.html">
            
                <a href="08_Functoriality.html">
            
                    
                    8章 関手性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" >
            
                <span>
            
                    
                    （工事中）9章 関数型
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10_Natural_transformations.html">
            
                <a href="10_Natural_transformations.html">
            
                    
                    10章 自然変換
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    第2部
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    （工事中）11章 宣言型プログラミング
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="12_Limits_and_Colimits.html">
            
                <a href="12_Limits_and_Colimits.html">
            
                    
                    12章 極限と余極限
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    付録
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="00_Notation.html">
            
                <a href="00_Notation.html">
            
                    
                    表記法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="tips/08_2_Writer_Functor.html">
            
                <a href="tips/08_2_Writer_Functor.html">
            
                    
                    Writer 圏における射の合成と、恒等射と、関手について
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            HonKitで公開 
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >8章 関手性</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <!-- omit in toc -->
<h1 id="8-関手性">8. 関手性</h1>
<p>前章では、圏と圏との間の対応である関手について定義し、いくつかのインスタンスを見ていきました。</p>
<p>本章では関手についてさらに深掘り、今後の議論の際に必要となるいくつかの関手について説明します。</p>
<p>まず、型構築子に2つの型パラメータを持つ関手である双関手について説明します。双関手の一般的な定義は直積圏を用いて与えられるので、直積圏についても説明します。双関手を用れば、積と余積を構成可能であることを示します。</p>
<p>次に、Reader 関手を2つの型パラメータを持つ型構築子 <code>Function1</code> として見たときの構造について説明します。Reader 関手は前章でも少し見まして、ある型を返すような関数を作る操作が関手であることが言えました。ここでは、Reader 関手に与える型パラメータを1つと固定する (返り値の型を指定する) のではなく、2つ指定する (引数と返り値の型を指定する) ことを考え、これと双関手の関係性について見ていきます。実は、2つの型パラメータをとる Reader 関手は、Profunctor と呼ばれる関手の1つであることがわかります。</p>
<p>最後に、Profunctor の具体例であって、圏論において重要な概念である Hom 関手について説明します。</p>
<p>少し難しいかもしれませんが、なるべくコードに落として学んでいければと思います！</p>
<!-- omit in toc -->
<h1 id="目次">目次</h1>
<ul>
<li><a href="#81-双関手">8.1 双関手</a><ul>
<li><a href="#811-直積圏を定義する">8.1.1 直積圏を定義する</a></li>
<li><a href="#812-双関手の一般的な定義">8.1.2 双関手の一般的な定義</a></li>
<li><a href="#813-tuple2-は双関手">8.1.3 Tuple2 は双関手</a></li>
<li><a href="#814-either-もまた双関手">8.1.4 Either もまた双関手</a></li>
</ul>
</li>
<li><a href="#82-reader-関手">8.2 Reader 関手</a><ul>
<li><a href="#821-function1-は双関手か">8.2.1 Function1 は双関手か？</a></li>
<li><a href="#822-function1-に対して-first-メソッドを定義する">8.2.2 Function1 に対して first メソッドを定義する</a></li>
<li><a href="#823-共変関手と反変関手">8.2.3 共変関手と反変関手</a></li>
</ul>
</li>
<li><a href="#83-profunctor">8.3 Profunctor</a></li>
<li><a href="#84-hom-関手">8.4 Hom 関手</a></li>
<li><a href="#まとめ">まとめ</a></li>
</ul>
<h2 id="81-双関手">8.1 双関手</h2>
<p><strong>双関手</strong> (bifunctor) は、型構築子に2つの型パラメータを持つ関手です。</p>
<p>双関手において、対象関数 <code>F[_, _]</code> を、2つの型 <code>A</code>、<code>B</code> を型 <code>F[A, B]</code> に対応させるものとして定義します。</p>
<p>また、射関数 <code>bimap</code> を、射 <code>A =&gt; C</code> と <code>B =&gt; D</code> に対して射 <code>F[A, B] =&gt; F[C, D]</code> を対応させるものとして定義します。</p>
<p>双関手の型クラスを定義すると、以下のようになります。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Bifunctor</span>[<span class="hljs-type">F</span>[_, _]]</span>:

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bimap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]
</code></pre>
<p><code>Bifunctor</code> 型クラスは、対象関数として型構築子 <code>F[_, _]</code> をもち、射関数として <code>bimap</code> メソッドをもちます。<code>bimap</code> メソッドがあれば、一方の関数のみを変換する <code>first</code> メソッドおよび <code>second</code> メソッドを定義できます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">extension</span> [<span class="hljs-type">F</span>[_, _]](bifunctor: <span class="hljs-type">Bifunctor</span>[<span class="hljs-type">F</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">B</span>] =
    bifunctor.bimap(f, identity[<span class="hljs-type">B</span>])

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">second</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">D</span>](g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">D</span>] =
    bifunctor.bimap(identity[<span class="hljs-type">A</span>], g)
</code></pre>
<p><img src="images/08_bifunctor.png" alt="双関手"></p>
<h3 id="811-直積圏を定義する">8.1.1 直積圏を定義する</h3>
<p>双関手の一般的な定義を与えるために、<strong>直積圏</strong> (product category) という概念を導入します。</p>
<p>2つの圏 <strong>C1</strong> と <strong>C2</strong> に対して、直積圏 <strong>C1 x C2</strong> を考えることができます。</p>
<p>直積圏 <strong>C1 x C2</strong> は、対象を <strong>C1</strong> の対象 a と <strong>C2</strong> の対象 b のペア (a, b) とします。</p>
<p>そして、射を <strong>C1</strong> の射 f: a -&gt; c と <strong>C2</strong> の射 g: b -&gt; d のペア (f, g) とします。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 直積圏における射</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fTuple</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">Tuple2</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>] = { <span class="hljs-keyword">case</span> (a, b) =&gt; (f(a), g(b)) }

<span class="hljs-keyword">val</span> lengthAndIsEven = fTuple[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Boolean</span>](_.length, _ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
<span class="hljs-comment">// lengthAndIsEven: Function1[Tuple2[String, Int], Tuple2[Int, Boolean]] = repl.MdocSession$MdocApp$$Lambda/0x00007f4199fc9000@22634</span>

lengthAndIsEven(<span class="hljs-string">&quot;hogehoge&quot;</span> -&gt; <span class="hljs-number">3</span>)
<span class="hljs-comment">// res0: Tuple2[Int, Boolean] = (8, false)</span>

lengthAndIsEven(<span class="hljs-string">&quot;&quot;</span> -&gt; <span class="hljs-number">4</span>)
<span class="hljs-comment">// res1: Tuple2[Int, Boolean] = (0, true)</span>
</code></pre>
<p>対象と射のペアをとっているだけですね。</p>
<p>射の合成についてもペアをとるだけです。<strong>C1</strong> における射の合成 h . f と <strong>C2</strong> における射の合成 k . g に対して、(h . f, k . g) は直積圏 <strong>C1 x C2</strong> における射の合成になります：</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 直積圏における射の合成</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">composeTuple</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>, <span class="hljs-type">E</span>, <span class="hljs-type">F</span>](fg: <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">Tuple2</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>], hk: <span class="hljs-type">Tuple2</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>] =&gt; <span class="hljs-type">Tuple2</span>[<span class="hljs-type">E</span>, <span class="hljs-type">F</span>]): <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">Tuple2</span>[<span class="hljs-type">E</span>, <span class="hljs-type">F</span>] =
  hk.compose(fg)

<span class="hljs-keyword">val</span> nonEmptyAndIsOdd = composeTuple(
  lengthAndIsEven,
  fTuple[<span class="hljs-type">Int</span>, <span class="hljs-type">Boolean</span>, <span class="hljs-type">Boolean</span>, <span class="hljs-type">Boolean</span>](_ &gt; <span class="hljs-number">0</span>, b =&gt; !b)
)
<span class="hljs-comment">// nonEmptyAndIsOdd: Function1[Tuple2[String, Int], Tuple2[Boolean, Boolean]] = scala.Function1$$Lambda/0x00007f4199e69fa8@551853fb</span>

nonEmptyAndIsOdd(<span class="hljs-string">&quot;hogehoge&quot;</span> -&gt; <span class="hljs-number">3</span>)
<span class="hljs-comment">// res2: Tuple2[Boolean, Boolean] = (true, true)</span>

nonEmptyAndIsOdd(<span class="hljs-string">&quot;&quot;</span> -&gt; <span class="hljs-number">4</span>)
<span class="hljs-comment">// res3: Tuple2[Boolean, Boolean] = (false, false)</span>
</code></pre>
<p>恒等射も同様に、<strong>C1</strong> の恒等射 identityC1 と <strong>C2</strong> の恒等射 identityC2 に対して (identityC1, identityC2) が直積圏の恒等射になります。</p>
<pre><code class="lang-scala"><span class="hljs-comment">// 直積圏における恒等射</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identityTuple</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = { <span class="hljs-keyword">case</span> (a, b) =&gt; (identity[<span class="hljs-type">A</span>](a), identity[<span class="hljs-type">B</span>](b)) }

<span class="hljs-comment">// または単に</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identityTuple2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]: <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = identity[<span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]]

identityTuple(<span class="hljs-string">&quot;hogehoge&quot;</span> -&gt; <span class="hljs-number">3</span>)
<span class="hljs-comment">// res4: Tuple2[String, Int] = (&quot;hogehoge&quot;, 3)</span>

identityTuple(<span class="hljs-string">&quot;&quot;</span> -&gt; <span class="hljs-number">4</span>)
<span class="hljs-comment">// res5: Tuple2[String, Int] = (&quot;&quot;, 4)</span>
</code></pre>
<h3 id="812-双関手の一般的な定義">8.1.2 双関手の一般的な定義</h3>
<p>さて、2つの圏の対象と射、射の合成をそれぞれペアにすることによって、直積圏を定義しました。双関手の話に戻りましょう。</p>
<p>一般的に、双関手は以下のように定義されます。</p>
<hr>
<p><strong>双関手</strong> (bifunctor) とは、2つの圏 <strong>C</strong> と <strong>D</strong> の直積圏 <strong>C x D</strong> から圏 <strong>E</strong> への関手のことです。</p>
<hr>
<p>Scala 圏において関手は自己関手となるので、Scala 圏における双関手 (すなわち Bifunctor) は Scala 圏と Scala 圏の直積から Scala 圏への関手になります。</p>
<p>すなわち、Bifunctor <code>F</code> は、対象関数 <code>F[_, _]</code> として Scala の直積圏の対象 <code>A</code> <code>B</code> を <code>F[A, B]</code> に対応させ、射関数 <code>bimap</code> として Scala の直積圏の射 <code>A =&gt; C</code> と <code>B =&gt; D</code> を <code>F</code> に関する射 <code>F[A, B] =&gt; F[C, D]</code> に対応させます。</p>
<p>では、双関手のいくつかの例をみていきましょう。</p>
<h3 id="813-tuple2-は双関手">8.1.3 Tuple2 は双関手</h3>
<p>双関手の重要な例として、積 (product) があります。対象の任意のペア <code>A</code> と <code>B</code> に対して積 <code>A x B</code> が存在する場合、これらの対象 <code>A</code> <code>B</code> から積 <code>A x B</code> への射は双関手の性質を満たします。Scala で最も単純な積 <code>Tuple2</code> に対して <code>Bifunctor</code> のインスタンスを与えましょう。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Bifunctor</span>[<span class="hljs-type">Tuple2</span>] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bimap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): <span class="hljs-type">Tuple2</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">Tuple2</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>] = {
    <span class="hljs-keyword">case</span> (a, b) =&gt; f(a) -&gt; g(b)
  }
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">// 例によって、これらの関数を f, g として利用してみます</span>
<span class="hljs-keyword">val</span> length: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Int</span> = _.length
<span class="hljs-comment">// length: Function1[String, Int] = repl.MdocSession$MdocApp$$Lambda/0x00007f4199fcb200@447bbc88</span>
<span class="hljs-keyword">val</span> isEven: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Boolean</span> = _ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
<span class="hljs-comment">// isEven: Function1[Int, Boolean] = repl.MdocSession$MdocApp$$Lambda/0x00007f4199fcb7e0@7612ee0f</span>

summon[<span class="hljs-type">Bifunctor</span>[<span class="hljs-type">Tuple2</span>]].bimap[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Boolean</span>](length, isEven)((<span class="hljs-string">&quot;hogehoge&quot;</span>, <span class="hljs-number">12345</span>))
<span class="hljs-comment">// res6: Tuple2[Int, Boolean] = (8, false)</span>
</code></pre>
<p>都度 summon するのは面倒なので、こちらも拡張メソッドを使って簡単に使えるようにしてみましょう。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">extension</span> [<span class="hljs-type">F</span>[_, _], <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](v: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>])
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bimap</span></span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>)(<span class="hljs-keyword">using</span> bf: <span class="hljs-type">Bifunctor</span>[<span class="hljs-type">F</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>] =
    bf.bimap(f, g)(v)
</code></pre>
<pre><code class="lang-scala">(<span class="hljs-string">&quot;hogehoge&quot;</span>, <span class="hljs-number">12345</span>).bimap(length, isEven)
<span class="hljs-comment">// res7: Tuple2[Int, Boolean] = (8, false)</span>
</code></pre>
<h3 id="814-either-もまた双関手">8.1.4 Either もまた双関手</h3>
<p>双対性によって、余積もまた、圏内の対象のすべてのペアに対して定義されているなら双関手になります。余積の一つである <code>Either</code> に対して <code>Bifunctor</code> のインスタンスを与えてみましょう。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Bifunctor</span>[<span class="hljs-type">Either</span>] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bimap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>] = {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(a)  =&gt; <span class="hljs-type">Left</span>(f(a))
    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(b) =&gt; <span class="hljs-type">Right</span>(g(b))
  }
</code></pre>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> right: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Right</span>(<span class="hljs-number">12345</span>)
<span class="hljs-comment">// right: Either[String, Int] = Right(value = 12345)</span>
<span class="hljs-keyword">val</span> left: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Left</span>(<span class="hljs-string">&quot;hogehoge&quot;</span>)
<span class="hljs-comment">// left: Either[String, Int] = Left(value = &quot;hogehoge&quot;)</span>

right.bimap(length, isEven)
<span class="hljs-comment">// res8: Either[Int, Boolean] = Right(value = false)</span>
left.bimap(length, isEven)
<span class="hljs-comment">// res9: Either[Int, Boolean] = Left(value = 8)</span>
</code></pre>
<h2 id="82-reader-関手">8.2 Reader 関手</h2>
<p>前章では型 <code>A</code> を <code>R =&gt; A</code> に対応させ、関数 <code>A =&gt; B</code> を <code>(R =&gt; A) =&gt; (R =&gt; B)</code> に引き上げる Reader 関手を考えました。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> [<span class="hljs-type">R</span>]: <span class="hljs-type">Functor</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Function1</span>[<span class="hljs-type">R</span>, <span class="hljs-type">X</span>]] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Function1</span>[<span class="hljs-type">R</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Function1</span>[<span class="hljs-type">R</span>, <span class="hljs-type">B</span>] = fa =&gt;
    f.compose(fa)
</code></pre>
<p>この型構築子 <code>Function1[_, _]</code> は2つの型パラメータを持つので、双関手の候補であると考えられます。</p>
<p>ここでは、<code>Function1</code> を双関手のインスタンスとして実装できるかどうかについて考えていきましょう。</p>
<h3 id="821-function1-は双関手か？">8.2.1 Function1 は双関手か？</h3>
<p><code>Bifunctor</code> のインスタンスでは、<code>bimap</code> を実装する必要があります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Bifunctor</span>[<span class="hljs-type">Function1</span>] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bimap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">C</span> =&gt; <span class="hljs-type">D</span>) = ???
</code></pre>
<p>どのように実装しましょうか？最終的には型 <code>C</code> の値 <code>c</code> を <code>D</code> に変換すれば良いだけですが、そのような手段はないように思えます。</p>
<p>別の方法を考えてみましょう。<code>bimap</code> は <code>first</code> および <code>second</code> を実装することによって、これらを組み合わせて実装することができます。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstReader</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">C</span> =&gt; <span class="hljs-type">B</span>) = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">secondReader</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">D</span>](g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">D</span>) = ???
</code></pre>
<p><code>second</code> メソッドは、Reader 関手の射関数です。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">second</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">D</span>](g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">D</span>) = fab =&gt; g.compose(fab)
</code></pre>
<p>では、<code>first</code> メソッドはどうでしょうか？</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">C</span> =&gt; <span class="hljs-type">B</span>) = ???
</code></pre>
<p>シグネチャを見ると分かる通り、関数 <code>A =&gt; C</code> と <code>A =&gt; B</code> の組み合わせでは <code>C =&gt; B</code> を構成することができません。</p>
<p><code>first</code> メソッドを定義できない、すなわち射関数 <code>bimap</code> を定義できないことから、<code>Function1</code> は双関手でないと言えます。</p>
<h3 id="822-function1-に対して-first-メソッドを定義する">8.2.2 Function1 に対して first メソッドを定義する</h3>
<p>前項で見た通り、関数 <code>A =&gt; C</code> と <code>A =&gt; B</code> からは <code>C =&gt; B</code> を構成することはできません。</p>
<p>しかしながら、関数 <code>f: A =&gt; C</code> の矢印を反転させて <code>oppF: C =&gt; A</code> を受け取れば、<code>first</code> メソッドを定義できます。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](oppF: <span class="hljs-type">C</span> =&gt; <span class="hljs-type">A</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">C</span> =&gt; <span class="hljs-type">B</span>) = _.compose(oppF)
</code></pre>
<p>少し言い換えると、直積圏における第1要素の射の矢印を入れ替えれば、第1要素の射を <code>Function1</code> に関する射に引き上げることができました。</p>
<p>さて、ある圏において、対象はそのままで射の矢印を入れ替えたものを、その圏の双対圏と呼ぶことができましたね。これはすなわち、<strong>Function1 が「Scala 圏の双対圏と Scala 圏の直積圏」から「Scala 圏」への関手となっている</strong>と言うことができます。<code>first</code> メソッドは、Scala の双対圏からの射関数であると言えます。</p>
<h3 id="823-共変関手と反変関手">8.2.3 共変関手と反変関手</h3>
<p>一般に、ある圏 <strong>C</strong> の双対圏 <strong>oppC</strong> からある圏 <strong>D</strong> への関手のことを<strong>反変関手</strong> (contravariant functor) と呼びます。</p>
<p>一方で、これまで話してきた標準の関手 (<code>Functor</code> 型クラス) は<strong>共変関手</strong> (covariant functor) と呼ばれます。</p>
<p>共変関手と同様に、反変関手の型クラス <code>Contravariant</code> は以下のように定義されます。対象関数 <code>F[_]</code> は共変関手と同じです。射関数 <code>contramap</code> は、射 <code>B =&gt; A</code> を <code>F</code> に関する射 <code>F[A] =&gt; F[B]</code> に引き上げます。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Contravariant</span>[<span class="hljs-type">F</span>[_]]</span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contramap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
</code></pre>
<p><code>Function1</code> の第1引数に対して <code>Contravariant</code> のインスタンスを以下のように実装できます。型の変数は違うものの、先ほどの見た <code>first</code> メソッドと同じ実装になっているはずです。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> [<span class="hljs-type">R</span>]: <span class="hljs-type">Contravariant</span>[[<span class="hljs-type">X</span>] =&gt;&gt; <span class="hljs-type">Function1</span>[<span class="hljs-type">X</span>, <span class="hljs-type">R</span>]] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contramap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">R</span>) =&gt; (<span class="hljs-type">B</span> =&gt; <span class="hljs-type">R</span>) =
    fa =&gt; fa.compose(f)
</code></pre>
<h2 id="83-profunctor">8.3 Profunctor</h2>
<p>共変関手と反変関手の概念を用いると、<code>Function1[_, _]</code> は、第1引数に関して反変であり、第2引数に関して共変であると言われます。</p>
<p>このように、1つ目の型パラメータが反変で2つ目の型パラメータが共変であるような型構築子は、<strong>Profunctor</strong> と呼ばれます。Profunctor も関手であって、対象関数は <code>F[_, _]</code> です。射関数 <code>dimap</code> は、第1引数 <code>C =&gt; A</code> を反変関手のように引き上げ、第2引数 <code>B =&gt; D</code> を共変関手のように引き上げることによって <code>F[A, B] =&gt; F[C, D]</code> に引き上げます。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Profunctor</span>[<span class="hljs-type">F</span>[_, _]]</span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dimap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">C</span> =&gt; <span class="hljs-type">A</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]
</code></pre>
<p>先ほど見たように、<code>Function1</code> は <code>Profunctor</code> です。<code>Function1</code> の <code>Profunctor</code> のインスタンスは、以下のように定義されます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">given</span> <span class="hljs-type">Profunctor</span>[<span class="hljs-type">Function1</span>] <span class="hljs-keyword">with</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dimap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">C</span> =&gt; <span class="hljs-type">A</span>, g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">D</span>): (<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) =&gt; (<span class="hljs-type">C</span> =&gt; <span class="hljs-type">D</span>) =
    fab =&gt; g.compose(fab.compose(f))
</code></pre>
<p>Profunctor の一般的な定義は、双対圏を用いて与えられます：</p>
<hr>
<p>圏 <strong>C</strong> から <strong>D</strong> への <strong>Profunctor</strong> とは、<strong>D</strong> の双対圏 <strong>oppD</strong> と <strong>C</strong> の直積圏 <strong>oppD x C</strong> から集合圏 <strong>Set</strong> への関手です。</p>
<hr>
<p>Scala 圏は集合圏の拡張であるため、Scala 圏の双対圏と Scala 圏の直積から Scala 圏への関手を Profunctor と定義することができます。</p>
<h2 id="84-hom-関手">8.4 Hom 関手</h2>
<p>本章の最後に、圏論における重要な概念である <strong>Hom 集合</strong> (hom set) について紹介します。一般に、ある圏 <strong>C</strong> の Hom 集合は、<strong>C</strong> の全ての射の集まり <strong>C</strong>(a, b) （a と b は <strong>C</strong> における任意の対象）として定義されます。</p>
<p>Scala 圏における Hom 集合は、射 a -&gt; b の集まり、すなわち <code>Function1[A, B]</code> です。<code>Function1[A, B]</code> を構成する操作は Profunctor で、Scala の双対圏と Scala 圏の直積圏から Scala 圏への関手のことでした。</p>
<p>これと同様に、Hom 集合を構成する操作も Profunctor であって、<strong>Hom 関手</strong> と呼ばれます。Profunctor として捉えると、ある圏 <strong>C</strong> の Hom 関手とは、直積圏 <strong>oppC x C</strong> から集合圏 <strong>Set</strong> への関手であると考えられます。</p>
<p><strong>oppC x C</strong> の射 (oppF: e =&gt; a, g: b =&gt; f) を Hom 関手によって引き上げると、Hom 集合 <strong>C</strong>(a, b) から Hom 集合 <strong>C</strong>(e, f) の集合に変換されます。ここで、<strong>C</strong>(a, b) のなんらかの要素 h （これは射 a -&gt; b の一つ）をとってきて</p>
<pre><code>g . h . oppF
</code></pre><p>とすると、これは射 e -&gt; f となり、<strong>C</strong>(e, f) の要素が得られます。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>2つの圏 <strong>C</strong> と <strong>D</strong> の直積圏とは、対象・射・射の合成それぞれを <strong>C</strong> と <strong>D</strong> のペアとして定義した圏のことである。<ul>
<li>対象：<code>(A, B)</code></li>
<li>射：<code>(A =&gt; C, B =&gt; D)</code></li>
<li>射の合成：<code>((C =&gt; E) compose (A =&gt; C), (D =&gt; H) compose (B =&gt; D))</code></li>
</ul>
</li>
<li>双関手は型構築子に2つの型パラメータを持った関手である。<ul>
<li>直積圏からの関手と定義される：<strong>C x D</strong> -&gt; <strong>E</strong></li>
<li>積関手である Tuple2 は、双関手である。</li>
<li>余積関手である Either は、双関手である。</li>
</ul>
</li>
<li>Function1 は型構築子に2つの型パラメータを持つが、双関手ではない。</li>
<li>ある圏の双対圏からの関手を反変関手という。</li>
<li>ある圏からの関手を共変関手という。</li>
<li>第1引数が反変で、第2引数が共変な関手を Profunctor という。<ul>
<li>Function1 は Profunctor である。</li>
<li>Profunctor は、双対圏との直積圏から集合圏への関手として定義される: <strong>oppC x D</strong> -&gt; <strong>Set</strong></li>
</ul>
</li>
<li>ある圏 <strong>C</strong> の Hom 集合とは、<strong>C</strong> の全ての射の集まりのことである。<ul>
<li>Scala 圏の Hom 集合は <code>Function1[A, B]</code> である。</li>
<li>2つの対象 a と b から Hom 集合  <strong>C</strong>(a, b) を作る操作は関手であり、Hom 関手と呼ばれる。</li>
<li>Hom 関手は、Profunctor である：<strong>oppC x C</strong> -&gt; <strong>Set</strong></li>
</ul>
</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="07_Functor.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 7章 関手">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"圏論の勉強記録です。本章では、関手についてさらに深掘ります。Writer 関手や双関手、Reader 関手、反変関手、Profunctor、Hom 関手について学びます。","title":"8章 関手性","level":"1.2.8","depth":2,"next":{"title":"（工事中）9章 関数型","level":"1.2.9","depth":2,"ref":"","articles":[]},"previous":{"title":"7章 関手","level":"1.2.7","depth":2,"path":"07_Functor.md","ref":"07_Functor.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./mdoc-output","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"taretmch","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Scala で始める圏論入門","language":"ja","gitbook":"*","description":"本サイトは、圏論初心者が圏論について学びながら作成した、Scala プログラマのための入門書です。教科書は Bartosz Milewski 氏著の Category Theory for Programmers の Scala Edition で、構成も原則これに沿っています。Scala をやっていて、圏論について知りたい・学ぶ土台を作りたいという方の参考になれば幸いです。"},"file":{"path":"08_Functoriality.md","mtime":"2024-06-30T13:28:04.817Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-06-30T13:28:08.742Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

